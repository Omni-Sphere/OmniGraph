// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// WARNING! Do not edit this file manually, your changes will be overwritten.

#include "QueryObject.h"
#include "MutationObject.h"

#include "graphqlservice/internal/Schema.h"

#include "graphqlservice/introspection/IntrospectionSchema.h"

#include <algorithm>
#include <array>
#include <functional>
#include <sstream>
#include <stdexcept>
#include <string_view>
#include <utility>
#include <vector>

using namespace std::literals;

namespace graphql {
namespace service {

static const auto s_namesLogoutReason = omnisphere::getLogoutReasonNames();
static const auto s_valuesLogoutReason = omnisphere::getLogoutReasonValues();

template <>
omnisphere::LogoutReason Argument<omnisphere::LogoutReason>::convert(const response::Value& value)
{
	if (!value.maybe_enum())
	{
		throw service::schema_exception { { R"ex(not a valid LogoutReason value)ex" } };
	}

	const auto result = internal::sorted_map_lookup<internal::shorter_or_less>(
		s_valuesLogoutReason,
		std::string_view { value.get<std::string>() });

	if (!result)
	{
		throw service::schema_exception { { R"ex(not a valid LogoutReason value)ex" } };
	}

	return *result;
}

template <>
service::AwaitableResolver Result<omnisphere::LogoutReason>::convert(service::AwaitableScalar<omnisphere::LogoutReason> result, ResolverParams&& params)
{
	return ModifiedResult<omnisphere::LogoutReason>::resolve(std::move(result), std::move(params),
		[](omnisphere::LogoutReason value, const ResolverParams&)
		{
			const auto idx = static_cast<size_t>(value);

			if (idx >= s_namesLogoutReason.size())
			{
				throw service::schema_exception { { R"ex(Enum value out of range for LogoutReason)ex" } };
			}

			response::Value resolvedResult(response::Type::EnumValue);

			resolvedResult.set<std::string>(std::string { s_namesLogoutReason[idx] });

			return resolvedResult;
		});
}

template <>
void Result<omnisphere::LogoutReason>::validateScalar(const response::Value& value)
{
	if (!value.maybe_enum())
	{
		throw service::schema_exception { { R"ex(not a valid LogoutReason value)ex" } };
	}

	const auto [itr, itrEnd] = internal::sorted_map_equal_range<internal::shorter_or_less>(
		s_valuesLogoutReason.begin(),
		s_valuesLogoutReason.end(),
		std::string_view { value.get<std::string>() });

	if (itr == itrEnd)
	{
		throw service::schema_exception { { R"ex(not a valid LogoutReason value)ex" } };
	}
}

template <>
omnisphere::CreateUserInput Argument<omnisphere::CreateUserInput>::convert(const response::Value& value)
{
	auto valueCode = service::ModifiedArgument<std::string>::require("Code", value);
	auto valueName = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Name", value);
	auto valueEmail = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Email", value);
	auto valuePhone = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Phone", value);
	auto valueEmployee = service::ModifiedArgument<int>::require<service::TypeModifier::Nullable>("Employee", value);
	auto valuePassword = service::ModifiedArgument<std::string>::require("Password", value);
	auto valueSuperUser = service::ModifiedArgument<bool>::require("SuperUser", value);
	auto valueChangePasswordNextLogin = service::ModifiedArgument<bool>::require("ChangePasswordNextLogin", value);
	auto valuePasswordNeverExpires = service::ModifiedArgument<bool>::require("PasswordNeverExpires", value);
	auto valueCreatedBy = service::ModifiedArgument<int>::require("CreatedBy", value);
	auto valueCreateDate = service::ModifiedArgument<std::string>::require("CreateDate", value);

	return omnisphere::CreateUserInput {
		std::move(valueCode),
		std::move(valueName),
		std::move(valueEmail),
		std::move(valuePhone),
		std::move(valueEmployee),
		std::move(valuePassword),
		valueSuperUser,
		valueChangePasswordNextLogin,
		valuePasswordNeverExpires,
		valueCreatedBy,
		std::move(valueCreateDate)
	};
}

template <>
omnisphere::CreateItemInput Argument<omnisphere::CreateItemInput>::convert(const response::Value& value)
{
	auto valueCode = service::ModifiedArgument<std::string>::require("Code", value);
	auto valueName = service::ModifiedArgument<std::string>::require("Name", value);
	auto valueDescription = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Description", value);
	auto valueImage = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Image", value);
	auto valueIsActive = service::ModifiedArgument<bool>::require<service::TypeModifier::Nullable>("IsActive", value);
	auto valuePurchaseItem = service::ModifiedArgument<bool>::require<service::TypeModifier::Nullable>("PurchaseItem", value);
	auto valueSellItem = service::ModifiedArgument<bool>::require<service::TypeModifier::Nullable>("SellItem", value);
	auto valueInventoryItem = service::ModifiedArgument<bool>::require<service::TypeModifier::Nullable>("InventoryItem", value);
	auto valuePrice = service::ModifiedArgument<double>::require("Price", value);
	auto valueBrand = service::ModifiedArgument<int>::require<service::TypeModifier::Nullable>("Brand", value);
	auto valueGroup = service::ModifiedArgument<int>::require<service::TypeModifier::Nullable>("Group", value);
	auto valueMinStock = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MinStock", value);
	auto valueMaxStock = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MaxStock", value);
	auto valueMinOrder = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MinOrder", value);
	auto valueMaxOrder = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MaxOrder", value);
	auto valueMinRequest = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MinRequest", value);
	auto valueMaxRequest = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MaxRequest", value);
	auto valueCreatedBy = service::ModifiedArgument<int>::require("CreatedBy", value);
	auto valueCreateDate = service::ModifiedArgument<std::string>::require("CreateDate", value);

	return omnisphere::CreateItemInput {
		std::move(valueCode),
		std::move(valueName),
		std::move(valueDescription),
		std::move(valueImage),
		std::move(valueIsActive),
		std::move(valuePurchaseItem),
		std::move(valueSellItem),
		std::move(valueInventoryItem),
		valuePrice,
		std::move(valueBrand),
		std::move(valueGroup),
		std::move(valueMinStock),
		std::move(valueMaxStock),
		std::move(valueMinOrder),
		std::move(valueMaxOrder),
		std::move(valueMinRequest),
		std::move(valueMaxRequest),
		valueCreatedBy,
		std::move(valueCreateDate)
	};
}

template <>
omnisphere::CreateItemBrandInput Argument<omnisphere::CreateItemBrandInput>::convert(const response::Value& value)
{
	auto valueCode = service::ModifiedArgument<std::string>::require("Code", value);
	auto valueName = service::ModifiedArgument<std::string>::require("Name", value);
	auto valueCreatedBy = service::ModifiedArgument<int>::require("CreatedBy", value);
	auto valueCreateDate = service::ModifiedArgument<std::string>::require("CreateDate", value);

	return omnisphere::CreateItemBrandInput {
		std::move(valueCode),
		std::move(valueName),
		valueCreatedBy,
		std::move(valueCreateDate)
	};
}

template <>
omnisphere::CreateItemGroupInput Argument<omnisphere::CreateItemGroupInput>::convert(const response::Value& value)
{
	auto valueCode = service::ModifiedArgument<std::string>::require("Code", value);
	auto valueName = service::ModifiedArgument<std::string>::require("Name", value);
	auto valueCreatedBy = service::ModifiedArgument<int>::require("CreatedBy", value);
	auto valueCreateDate = service::ModifiedArgument<std::string>::require("CreateDate", value);

	return omnisphere::CreateItemGroupInput {
		std::move(valueCode),
		std::move(valueName),
		valueCreatedBy,
		std::move(valueCreateDate)
	};
}

template <>
omnisphere::UpdateUserFilter Argument<omnisphere::UpdateUserFilter>::convert(const response::Value& value)
{
	auto valueEntry = service::ModifiedArgument<int>::require("Entry", value);
	auto valueCode = service::ModifiedArgument<std::string>::require("Code", value);

	return omnisphere::UpdateUserFilter {
		valueEntry,
		std::move(valueCode)
	};
}

template <>
omnisphere::UpdateUserDataInput Argument<omnisphere::UpdateUserDataInput>::convert(const response::Value& value)
{
	auto valueName = service::ModifiedArgument<std::string>::require("Name", value);
	auto valueEmail = service::ModifiedArgument<std::string>::require("Email", value);
	auto valuePhone = service::ModifiedArgument<std::string>::require("Phone", value);
	auto valueEmployee = service::ModifiedArgument<int>::require("Employee", value);

	return omnisphere::UpdateUserDataInput {
		std::move(valueName),
		std::move(valueEmail),
		std::move(valuePhone),
		valueEmployee
	};
}

template <>
omnisphere::UpdateItemInput Argument<omnisphere::UpdateItemInput>::convert(const response::Value& value)
{
	auto valueCode = service::ModifiedArgument<std::string>::require("Code", value);
	auto valueName = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Name", value);
	auto valueDescription = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Description", value);
	auto valueImage = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Image", value);
	auto valueIsActive = service::ModifiedArgument<bool>::require<service::TypeModifier::Nullable>("IsActive", value);
	auto valuePurchaseItem = service::ModifiedArgument<bool>::require<service::TypeModifier::Nullable>("PurchaseItem", value);
	auto valueSellItem = service::ModifiedArgument<bool>::require<service::TypeModifier::Nullable>("SellItem", value);
	auto valueInventoryItem = service::ModifiedArgument<bool>::require<service::TypeModifier::Nullable>("InventoryItem", value);
	auto valuePrice = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("Price", value);
	auto valueBrand = service::ModifiedArgument<int>::require<service::TypeModifier::Nullable>("Brand", value);
	auto valueGroup = service::ModifiedArgument<int>::require<service::TypeModifier::Nullable>("Group", value);
	auto valueMinStock = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MinStock", value);
	auto valueMaxStock = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MaxStock", value);
	auto valueMinOrder = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MinOrder", value);
	auto valueMaxOrder = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MaxOrder", value);
	auto valueMinRequest = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MinRequest", value);
	auto valueMaxRequest = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MaxRequest", value);
	auto valueLastUpdatedBy = service::ModifiedArgument<int>::require("LastUpdatedBy", value);
	auto valueUpdateDate = service::ModifiedArgument<std::string>::require("UpdateDate", value);

	return omnisphere::UpdateItemInput {
		std::move(valueCode),
		std::move(valueName),
		std::move(valueDescription),
		std::move(valueImage),
		std::move(valueIsActive),
		std::move(valuePurchaseItem),
		std::move(valueSellItem),
		std::move(valueInventoryItem),
		std::move(valuePrice),
		std::move(valueBrand),
		std::move(valueGroup),
		std::move(valueMinStock),
		std::move(valueMaxStock),
		std::move(valueMinOrder),
		std::move(valueMaxOrder),
		std::move(valueMinRequest),
		std::move(valueMaxRequest),
		valueLastUpdatedBy,
		std::move(valueUpdateDate)
	};
}

template <>
omnisphere::UpdateItemBrandInput Argument<omnisphere::UpdateItemBrandInput>::convert(const response::Value& value)
{
	auto valueCode = service::ModifiedArgument<std::string>::require("Code", value);
	auto valueName = service::ModifiedArgument<std::string>::require("Name", value);
	auto valueLastUpdatedBy = service::ModifiedArgument<int>::require("LastUpdatedBy", value);
	auto valueUpdateDate = service::ModifiedArgument<std::string>::require("UpdateDate", value);

	return omnisphere::UpdateItemBrandInput {
		std::move(valueCode),
		std::move(valueName),
		valueLastUpdatedBy,
		std::move(valueUpdateDate)
	};
}

template <>
omnisphere::GetUserInput Argument<omnisphere::GetUserInput>::convert(const response::Value& value)
{
	auto valueEntry = service::ModifiedArgument<int>::require<service::TypeModifier::Nullable>("Entry", value);
	auto valueCode = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Code", value);
	auto valueName = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Name", value);
	auto valueEmail = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Email", value);
	auto valuePhone = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Phone", value);
	auto valueEmployee = service::ModifiedArgument<int>::require<service::TypeModifier::Nullable>("Employee", value);

	return omnisphere::GetUserInput {
		std::move(valueEntry),
		std::move(valueCode),
		std::move(valueName),
		std::move(valueEmail),
		std::move(valuePhone),
		std::move(valueEmployee)
	};
}

template <>
omnisphere::GetItemInput Argument<omnisphere::GetItemInput>::convert(const response::Value& value)
{
	auto valueEntry = service::ModifiedArgument<int>::require<service::TypeModifier::Nullable>("Entry", value);
	auto valueCode = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Code", value);
	auto valueName = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Name", value);

	return omnisphere::GetItemInput {
		std::move(valueEntry),
		std::move(valueCode),
		std::move(valueName)
	};
}

template <>
omnisphere::GetItemGroupInput Argument<omnisphere::GetItemGroupInput>::convert(const response::Value& value)
{
	auto valueCode = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Code", value);
	auto valueName = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Name", value);

	return omnisphere::GetItemGroupInput {
		std::move(valueCode),
		std::move(valueName)
	};
}

template <>
omnisphere::GetItemBrandInput Argument<omnisphere::GetItemBrandInput>::convert(const response::Value& value)
{
	auto valueCode = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Code", value);
	auto valueName = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Name", value);

	return omnisphere::GetItemBrandInput {
		std::move(valueCode),
		std::move(valueName)
	};
}

template <>
omnisphere::SearchUsersInput Argument<omnisphere::SearchUsersInput>::convert(const response::Value& value)
{
	auto valueAllOff = service::ModifiedArgument<bool>::require("AllOff", value);
	auto valueAnyOff = service::ModifiedArgument<bool>::require("AnyOff", value);
	auto valueCodeEqualsTo = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("CodeEqualsTo", value);
	auto valueCodeContains = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("CodeContains", value);
	auto valueNameEqualsTo = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("NameEqualsTo", value);
	auto valueNameConatins = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("NameConatins", value);
	auto valueEmailEqualsTo = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("EmailEqualsTo", value);
	auto valueEmailContains = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("EmailContains", value);
	auto valuePhoneEqualsTo = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("PhoneEqualsTo", value);
	auto valuePhoneContains = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("PhoneContains", value);
	auto valueInactiveUsers = service::ModifiedArgument<bool>::require<service::TypeModifier::Nullable>("InactiveUsers", value);
	auto valueLockedUsers = service::ModifiedArgument<bool>::require<service::TypeModifier::Nullable>("LockedUsers", value);
	auto valueHasEmployee = service::ModifiedArgument<bool>::require<service::TypeModifier::Nullable>("HasEmployee", value);

	return omnisphere::SearchUsersInput {
		valueAllOff,
		valueAnyOff,
		std::move(valueCodeEqualsTo),
		std::move(valueCodeContains),
		std::move(valueNameEqualsTo),
		std::move(valueNameConatins),
		std::move(valueEmailEqualsTo),
		std::move(valueEmailContains),
		std::move(valuePhoneEqualsTo),
		std::move(valuePhoneContains),
		std::move(valueInactiveUsers),
		std::move(valueLockedUsers),
		std::move(valueHasEmployee)
	};
}

template <>
omnisphere::SearchItemsInput Argument<omnisphere::SearchItemsInput>::convert(const response::Value& value)
{
	auto valueCodeEqualsTo = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("CodeEqualsTo", value);
	auto valueCodeContains = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("CodeContains", value);
	auto valueNameEqualsTo = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("NameEqualsTo", value);
	auto valueNameContains = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("NameContains", value);
	auto valueDescriptionEqualsTo = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("DescriptionEqualsTo", value);
	auto valueDescriptionContains = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("DescriptionContains", value);
	auto valueIsActive = service::ModifiedArgument<bool>::require<service::TypeModifier::Nullable>("IsActive", value);
	auto valuePurchaseItem = service::ModifiedArgument<bool>::require<service::TypeModifier::Nullable>("PurchaseItem", value);
	auto valueSellItem = service::ModifiedArgument<bool>::require<service::TypeModifier::Nullable>("SellItem", value);
	auto valueInventoryItem = service::ModifiedArgument<bool>::require<service::TypeModifier::Nullable>("InventoryItem", value);
	auto valuePrice = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("Price", value);
	auto valueOnHandEqualsTo = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("OnHandEqualsTo", value);
	auto valueOnHandGreaterThan = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("OnHandGreaterThan", value);
	auto valueOnHandLessThan = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("OnHandLessThan", value);
	auto valueOnRequestEqualsTo = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("OnRequestEqualsTo", value);
	auto valueOnRequestGreaterThan = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("OnRequestGreaterThan", value);
	auto valueOnRequestLessThan = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("OnRequestLessThan", value);
	auto valueOnOrderEqualsTo = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("OnOrderEqualsTo", value);
	auto valueOnOrderGreaterThan = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("OnOrderGreaterThan", value);
	auto valueOnOrderLessThan = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("OnOrderLessThan", value);
	auto valueMinStockEqualsTo = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MinStockEqualsTo", value);
	auto valueMinStockGreaterThan = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MinStockGreaterThan", value);
	auto valueMinStockLessThan = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MinStockLessThan", value);
	auto valueMaxStockEqualsTo = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MaxStockEqualsTo", value);
	auto valueMaxStockGreaterThan = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MaxStockGreaterThan", value);
	auto valueMaxStockLessThan = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MaxStockLessThan", value);
	auto valueMinOrderEqualsTo = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MinOrderEqualsTo", value);
	auto valueMinOrderGreaterThan = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MinOrderGreaterThan", value);
	auto valueMinOrderLessThan = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MinOrderLessThan", value);
	auto valueMaxOrderEqualsTo = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MaxOrderEqualsTo", value);
	auto valueMaxOrderGreaterThan = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MaxOrderGreaterThan", value);
	auto valueMaxOrderLessThan = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MaxOrderLessThan", value);
	auto valueMinRequestEqualsTo = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MinRequestEqualsTo", value);
	auto valueMinRequestGreaterThan = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MinRequestGreaterThan", value);
	auto valueMinRequestLessThan = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MinRequestLessThan", value);
	auto valueMaxReqeuestEqualsTo = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MaxReqeuestEqualsTo", value);
	auto valueMaxRequestGreaterThan = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MaxRequestGreaterThan", value);
	auto valueMaxRequestLessThan = service::ModifiedArgument<double>::require<service::TypeModifier::Nullable>("MaxRequestLessThan", value);

	return omnisphere::SearchItemsInput {
		std::move(valueCodeEqualsTo),
		std::move(valueCodeContains),
		std::move(valueNameEqualsTo),
		std::move(valueNameContains),
		std::move(valueDescriptionEqualsTo),
		std::move(valueDescriptionContains),
		std::move(valueIsActive),
		std::move(valuePurchaseItem),
		std::move(valueSellItem),
		std::move(valueInventoryItem),
		std::move(valuePrice),
		std::move(valueOnHandEqualsTo),
		std::move(valueOnHandGreaterThan),
		std::move(valueOnHandLessThan),
		std::move(valueOnRequestEqualsTo),
		std::move(valueOnRequestGreaterThan),
		std::move(valueOnRequestLessThan),
		std::move(valueOnOrderEqualsTo),
		std::move(valueOnOrderGreaterThan),
		std::move(valueOnOrderLessThan),
		std::move(valueMinStockEqualsTo),
		std::move(valueMinStockGreaterThan),
		std::move(valueMinStockLessThan),
		std::move(valueMaxStockEqualsTo),
		std::move(valueMaxStockGreaterThan),
		std::move(valueMaxStockLessThan),
		std::move(valueMinOrderEqualsTo),
		std::move(valueMinOrderGreaterThan),
		std::move(valueMinOrderLessThan),
		std::move(valueMaxOrderEqualsTo),
		std::move(valueMaxOrderGreaterThan),
		std::move(valueMaxOrderLessThan),
		std::move(valueMinRequestEqualsTo),
		std::move(valueMinRequestGreaterThan),
		std::move(valueMinRequestLessThan),
		std::move(valueMaxReqeuestEqualsTo),
		std::move(valueMaxRequestGreaterThan),
		std::move(valueMaxRequestLessThan)
	};
}

template <>
omnisphere::SearchItemGroupsInput Argument<omnisphere::SearchItemGroupsInput>::convert(const response::Value& value)
{
	auto valueNameEqualsTo = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("NameEqualsTo", value);
	auto valueNameContains = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("NameContains", value);

	return omnisphere::SearchItemGroupsInput {
		std::move(valueNameEqualsTo),
		std::move(valueNameContains)
	};
}

template <>
omnisphere::SearchItemBrandsInput Argument<omnisphere::SearchItemBrandsInput>::convert(const response::Value& value)
{
	auto valueNameEqualsTo = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("NameEqualsTo", value);
	auto valueNameContains = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("NameContains", value);

	return omnisphere::SearchItemBrandsInput {
		std::move(valueNameEqualsTo),
		std::move(valueNameContains)
	};
}

template <>
omnisphere::ChangePasswordInput Argument<omnisphere::ChangePasswordInput>::convert(const response::Value& value)
{
	auto valueEntry = service::ModifiedArgument<int>::require<service::TypeModifier::Nullable>("Entry", value);
	auto valueCode = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Code", value);
	auto valueOldPassword = service::ModifiedArgument<std::string>::require("OldPassword", value);
	auto valueNewPassword = service::ModifiedArgument<std::string>::require("NewPassword", value);
	auto valueUpdateDate = service::ModifiedArgument<std::string>::require("UpdateDate", value);
	auto valueUpdatedBy = service::ModifiedArgument<int>::require("UpdatedBy", value);

	return omnisphere::ChangePasswordInput {
		std::move(valueEntry),
		std::move(valueCode),
		std::move(valueOldPassword),
		std::move(valueNewPassword),
		std::move(valueUpdateDate),
		valueUpdatedBy
	};
}

template <>
omnisphere::UpdateUserPoliciesInput Argument<omnisphere::UpdateUserPoliciesInput>::convert(const response::Value& value)
{
	auto valueEntry = service::ModifiedArgument<int>::require("Entry", value);
	auto valueCode = service::ModifiedArgument<std::string>::require("Code", value);
	auto valueIsActive = service::ModifiedArgument<bool>::require("IsActive", value);
	auto valueIsLocked = service::ModifiedArgument<bool>::require("IsLocked", value);
	auto valueSuperUser = service::ModifiedArgument<bool>::require("SuperUser", value);
	auto valueChangePasswordNextLogin = service::ModifiedArgument<bool>::require("ChangePasswordNextLogin", value);
	auto valuePasswordNeverExpires = service::ModifiedArgument<bool>::require("PasswordNeverExpires", value);
	auto valueUpdateDate = service::ModifiedArgument<std::string>::require("UpdateDate", value);
	auto valueUpdatedBy = service::ModifiedArgument<int>::require("UpdatedBy", value);

	return omnisphere::UpdateUserPoliciesInput {
		valueEntry,
		std::move(valueCode),
		valueIsActive,
		valueIsLocked,
		valueSuperUser,
		valueChangePasswordNextLogin,
		valuePasswordNeverExpires,
		std::move(valueUpdateDate),
		valueUpdatedBy
	};
}

template <>
omnisphere::UpdateItemGroupInput Argument<omnisphere::UpdateItemGroupInput>::convert(const response::Value& value)
{
	auto valueCode = service::ModifiedArgument<std::string>::require("Code", value);
	auto valueName = service::ModifiedArgument<std::string>::require("Name", value);
	auto valueLastUpdatedBy = service::ModifiedArgument<int>::require("LastUpdatedBy", value);
	auto valueUpdateDate = service::ModifiedArgument<std::string>::require("UpdateDate", value);

	return omnisphere::UpdateItemGroupInput {
		std::move(valueCode),
		std::move(valueName),
		valueLastUpdatedBy,
		std::move(valueUpdateDate)
	};
}

template <>
omnisphere::SessionParams Argument<omnisphere::SessionParams>::convert(const response::Value& value)
{
	auto valueCode = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Code", value);
	auto valueEmail = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Email", value);
	auto valuePhone = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Phone", value);
	auto valueStartDate = service::ModifiedArgument<std::string>::require("StartDate", value);
	auto valueDeviceIP = service::ModifiedArgument<std::string>::require("DeviceIP", value);
	auto valueHostName = service::ModifiedArgument<std::string>::require("HostName", value);
	auto valuePassword = service::ModifiedArgument<std::string>::require("Password", value);

	return omnisphere::SessionParams {
		std::move(valueCode),
		std::move(valueEmail),
		std::move(valuePhone),
		std::move(valueStartDate),
		std::move(valueDeviceIP),
		std::move(valueHostName),
		std::move(valuePassword)
	};
}

template <>
omnisphere::LogoutParams Argument<omnisphere::LogoutParams>::convert(const response::Value& value)
{
	auto valueSessionUUID = service::ModifiedArgument<std::string>::require("SessionUUID", value);
	auto valueEndDate = service::ModifiedArgument<std::string>::require("EndDate", value);
	auto valueReason = service::ModifiedArgument<omnisphere::LogoutReason>::require("Reason", value);
	auto valueMessage = service::ModifiedArgument<std::string>::require<service::TypeModifier::Nullable>("Message", value);

	return omnisphere::LogoutParams {
		std::move(valueSessionUUID),
		std::move(valueEndDate),
		std::move(valueReason),
		std::move(valueMessage)
	};
}

template <>
omnisphere::UpdateUserInput Argument<omnisphere::UpdateUserInput>::convert(const response::Value& value)
{
	auto valueWhere = service::ModifiedArgument<omnisphere::UpdateUserFilter>::require("Where", value);
	auto valueData = service::ModifiedArgument<omnisphere::UpdateUserDataInput>::require("Data", value);
	auto valueUpdateDate = service::ModifiedArgument<std::string>::require("UpdateDate", value);
	auto valueUpdatedBy = service::ModifiedArgument<int>::require("UpdatedBy", value);

	return omnisphere::UpdateUserInput {
		std::move(valueWhere),
		std::move(valueData),
		std::move(valueUpdateDate),
		valueUpdatedBy
	};
}

} // namespace service

namespace omnisphere {

CreateUserInput::CreateUserInput() noexcept
	: Code {}
	, Name {}
	, Email {}
	, Phone {}
	, Employee {}
	, Password {}
	, SuperUser {}
	, ChangePasswordNextLogin {}
	, PasswordNeverExpires {}
	, CreatedBy {}
	, CreateDate {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

CreateUserInput::CreateUserInput(
		std::string CodeArg,
		std::optional<std::string> NameArg,
		std::optional<std::string> EmailArg,
		std::optional<std::string> PhoneArg,
		std::optional<int> EmployeeArg,
		std::string PasswordArg,
		bool SuperUserArg,
		bool ChangePasswordNextLoginArg,
		bool PasswordNeverExpiresArg,
		int CreatedByArg,
		std::string CreateDateArg) noexcept
	: Code { std::move(CodeArg) }
	, Name { std::move(NameArg) }
	, Email { std::move(EmailArg) }
	, Phone { std::move(PhoneArg) }
	, Employee { std::move(EmployeeArg) }
	, Password { std::move(PasswordArg) }
	, SuperUser { std::move(SuperUserArg) }
	, ChangePasswordNextLogin { std::move(ChangePasswordNextLoginArg) }
	, PasswordNeverExpires { std::move(PasswordNeverExpiresArg) }
	, CreatedBy { std::move(CreatedByArg) }
	, CreateDate { std::move(CreateDateArg) }
{
}

CreateUserInput::CreateUserInput(const CreateUserInput& other)
	: Code { service::ModifiedArgument<std::string>::duplicate(other.Code) }
	, Name { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Name) }
	, Email { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Email) }
	, Phone { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Phone) }
	, Employee { service::ModifiedArgument<int>::duplicate<service::TypeModifier::Nullable>(other.Employee) }
	, Password { service::ModifiedArgument<std::string>::duplicate(other.Password) }
	, SuperUser { service::ModifiedArgument<bool>::duplicate(other.SuperUser) }
	, ChangePasswordNextLogin { service::ModifiedArgument<bool>::duplicate(other.ChangePasswordNextLogin) }
	, PasswordNeverExpires { service::ModifiedArgument<bool>::duplicate(other.PasswordNeverExpires) }
	, CreatedBy { service::ModifiedArgument<int>::duplicate(other.CreatedBy) }
	, CreateDate { service::ModifiedArgument<std::string>::duplicate(other.CreateDate) }
{
}

CreateUserInput::CreateUserInput(CreateUserInput&& other) noexcept
	: Code { std::move(other.Code) }
	, Name { std::move(other.Name) }
	, Email { std::move(other.Email) }
	, Phone { std::move(other.Phone) }
	, Employee { std::move(other.Employee) }
	, Password { std::move(other.Password) }
	, SuperUser { std::move(other.SuperUser) }
	, ChangePasswordNextLogin { std::move(other.ChangePasswordNextLogin) }
	, PasswordNeverExpires { std::move(other.PasswordNeverExpires) }
	, CreatedBy { std::move(other.CreatedBy) }
	, CreateDate { std::move(other.CreateDate) }
{
}

CreateUserInput::~CreateUserInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

CreateUserInput& CreateUserInput::operator=(const CreateUserInput& other)
{
	CreateUserInput value { other };

	std::swap(*this, value);

	return *this;
}

CreateUserInput& CreateUserInput::operator=(CreateUserInput&& other) noexcept
{
	Code = std::move(other.Code);
	Name = std::move(other.Name);
	Email = std::move(other.Email);
	Phone = std::move(other.Phone);
	Employee = std::move(other.Employee);
	Password = std::move(other.Password);
	SuperUser = std::move(other.SuperUser);
	ChangePasswordNextLogin = std::move(other.ChangePasswordNextLogin);
	PasswordNeverExpires = std::move(other.PasswordNeverExpires);
	CreatedBy = std::move(other.CreatedBy);
	CreateDate = std::move(other.CreateDate);

	return *this;
}

CreateItemInput::CreateItemInput() noexcept
	: Code {}
	, Name {}
	, Description {}
	, Image {}
	, IsActive {}
	, PurchaseItem {}
	, SellItem {}
	, InventoryItem {}
	, Price {}
	, Brand {}
	, Group {}
	, MinStock {}
	, MaxStock {}
	, MinOrder {}
	, MaxOrder {}
	, MinRequest {}
	, MaxRequest {}
	, CreatedBy {}
	, CreateDate {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

CreateItemInput::CreateItemInput(
		std::string CodeArg,
		std::string NameArg,
		std::optional<std::string> DescriptionArg,
		std::optional<std::string> ImageArg,
		std::optional<bool> IsActiveArg,
		std::optional<bool> PurchaseItemArg,
		std::optional<bool> SellItemArg,
		std::optional<bool> InventoryItemArg,
		double PriceArg,
		std::optional<int> BrandArg,
		std::optional<int> GroupArg,
		std::optional<double> MinStockArg,
		std::optional<double> MaxStockArg,
		std::optional<double> MinOrderArg,
		std::optional<double> MaxOrderArg,
		std::optional<double> MinRequestArg,
		std::optional<double> MaxRequestArg,
		int CreatedByArg,
		std::string CreateDateArg) noexcept
	: Code { std::move(CodeArg) }
	, Name { std::move(NameArg) }
	, Description { std::move(DescriptionArg) }
	, Image { std::move(ImageArg) }
	, IsActive { std::move(IsActiveArg) }
	, PurchaseItem { std::move(PurchaseItemArg) }
	, SellItem { std::move(SellItemArg) }
	, InventoryItem { std::move(InventoryItemArg) }
	, Price { std::move(PriceArg) }
	, Brand { std::move(BrandArg) }
	, Group { std::move(GroupArg) }
	, MinStock { std::move(MinStockArg) }
	, MaxStock { std::move(MaxStockArg) }
	, MinOrder { std::move(MinOrderArg) }
	, MaxOrder { std::move(MaxOrderArg) }
	, MinRequest { std::move(MinRequestArg) }
	, MaxRequest { std::move(MaxRequestArg) }
	, CreatedBy { std::move(CreatedByArg) }
	, CreateDate { std::move(CreateDateArg) }
{
}

CreateItemInput::CreateItemInput(const CreateItemInput& other)
	: Code { service::ModifiedArgument<std::string>::duplicate(other.Code) }
	, Name { service::ModifiedArgument<std::string>::duplicate(other.Name) }
	, Description { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Description) }
	, Image { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Image) }
	, IsActive { service::ModifiedArgument<bool>::duplicate<service::TypeModifier::Nullable>(other.IsActive) }
	, PurchaseItem { service::ModifiedArgument<bool>::duplicate<service::TypeModifier::Nullable>(other.PurchaseItem) }
	, SellItem { service::ModifiedArgument<bool>::duplicate<service::TypeModifier::Nullable>(other.SellItem) }
	, InventoryItem { service::ModifiedArgument<bool>::duplicate<service::TypeModifier::Nullable>(other.InventoryItem) }
	, Price { service::ModifiedArgument<double>::duplicate(other.Price) }
	, Brand { service::ModifiedArgument<int>::duplicate<service::TypeModifier::Nullable>(other.Brand) }
	, Group { service::ModifiedArgument<int>::duplicate<service::TypeModifier::Nullable>(other.Group) }
	, MinStock { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MinStock) }
	, MaxStock { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MaxStock) }
	, MinOrder { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MinOrder) }
	, MaxOrder { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MaxOrder) }
	, MinRequest { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MinRequest) }
	, MaxRequest { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MaxRequest) }
	, CreatedBy { service::ModifiedArgument<int>::duplicate(other.CreatedBy) }
	, CreateDate { service::ModifiedArgument<std::string>::duplicate(other.CreateDate) }
{
}

CreateItemInput::CreateItemInput(CreateItemInput&& other) noexcept
	: Code { std::move(other.Code) }
	, Name { std::move(other.Name) }
	, Description { std::move(other.Description) }
	, Image { std::move(other.Image) }
	, IsActive { std::move(other.IsActive) }
	, PurchaseItem { std::move(other.PurchaseItem) }
	, SellItem { std::move(other.SellItem) }
	, InventoryItem { std::move(other.InventoryItem) }
	, Price { std::move(other.Price) }
	, Brand { std::move(other.Brand) }
	, Group { std::move(other.Group) }
	, MinStock { std::move(other.MinStock) }
	, MaxStock { std::move(other.MaxStock) }
	, MinOrder { std::move(other.MinOrder) }
	, MaxOrder { std::move(other.MaxOrder) }
	, MinRequest { std::move(other.MinRequest) }
	, MaxRequest { std::move(other.MaxRequest) }
	, CreatedBy { std::move(other.CreatedBy) }
	, CreateDate { std::move(other.CreateDate) }
{
}

CreateItemInput::~CreateItemInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

CreateItemInput& CreateItemInput::operator=(const CreateItemInput& other)
{
	CreateItemInput value { other };

	std::swap(*this, value);

	return *this;
}

CreateItemInput& CreateItemInput::operator=(CreateItemInput&& other) noexcept
{
	Code = std::move(other.Code);
	Name = std::move(other.Name);
	Description = std::move(other.Description);
	Image = std::move(other.Image);
	IsActive = std::move(other.IsActive);
	PurchaseItem = std::move(other.PurchaseItem);
	SellItem = std::move(other.SellItem);
	InventoryItem = std::move(other.InventoryItem);
	Price = std::move(other.Price);
	Brand = std::move(other.Brand);
	Group = std::move(other.Group);
	MinStock = std::move(other.MinStock);
	MaxStock = std::move(other.MaxStock);
	MinOrder = std::move(other.MinOrder);
	MaxOrder = std::move(other.MaxOrder);
	MinRequest = std::move(other.MinRequest);
	MaxRequest = std::move(other.MaxRequest);
	CreatedBy = std::move(other.CreatedBy);
	CreateDate = std::move(other.CreateDate);

	return *this;
}

CreateItemBrandInput::CreateItemBrandInput() noexcept
	: Code {}
	, Name {}
	, CreatedBy {}
	, CreateDate {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

CreateItemBrandInput::CreateItemBrandInput(
		std::string CodeArg,
		std::string NameArg,
		int CreatedByArg,
		std::string CreateDateArg) noexcept
	: Code { std::move(CodeArg) }
	, Name { std::move(NameArg) }
	, CreatedBy { std::move(CreatedByArg) }
	, CreateDate { std::move(CreateDateArg) }
{
}

CreateItemBrandInput::CreateItemBrandInput(const CreateItemBrandInput& other)
	: Code { service::ModifiedArgument<std::string>::duplicate(other.Code) }
	, Name { service::ModifiedArgument<std::string>::duplicate(other.Name) }
	, CreatedBy { service::ModifiedArgument<int>::duplicate(other.CreatedBy) }
	, CreateDate { service::ModifiedArgument<std::string>::duplicate(other.CreateDate) }
{
}

CreateItemBrandInput::CreateItemBrandInput(CreateItemBrandInput&& other) noexcept
	: Code { std::move(other.Code) }
	, Name { std::move(other.Name) }
	, CreatedBy { std::move(other.CreatedBy) }
	, CreateDate { std::move(other.CreateDate) }
{
}

CreateItemBrandInput::~CreateItemBrandInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

CreateItemBrandInput& CreateItemBrandInput::operator=(const CreateItemBrandInput& other)
{
	CreateItemBrandInput value { other };

	std::swap(*this, value);

	return *this;
}

CreateItemBrandInput& CreateItemBrandInput::operator=(CreateItemBrandInput&& other) noexcept
{
	Code = std::move(other.Code);
	Name = std::move(other.Name);
	CreatedBy = std::move(other.CreatedBy);
	CreateDate = std::move(other.CreateDate);

	return *this;
}

CreateItemGroupInput::CreateItemGroupInput() noexcept
	: Code {}
	, Name {}
	, CreatedBy {}
	, CreateDate {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

CreateItemGroupInput::CreateItemGroupInput(
		std::string CodeArg,
		std::string NameArg,
		int CreatedByArg,
		std::string CreateDateArg) noexcept
	: Code { std::move(CodeArg) }
	, Name { std::move(NameArg) }
	, CreatedBy { std::move(CreatedByArg) }
	, CreateDate { std::move(CreateDateArg) }
{
}

CreateItemGroupInput::CreateItemGroupInput(const CreateItemGroupInput& other)
	: Code { service::ModifiedArgument<std::string>::duplicate(other.Code) }
	, Name { service::ModifiedArgument<std::string>::duplicate(other.Name) }
	, CreatedBy { service::ModifiedArgument<int>::duplicate(other.CreatedBy) }
	, CreateDate { service::ModifiedArgument<std::string>::duplicate(other.CreateDate) }
{
}

CreateItemGroupInput::CreateItemGroupInput(CreateItemGroupInput&& other) noexcept
	: Code { std::move(other.Code) }
	, Name { std::move(other.Name) }
	, CreatedBy { std::move(other.CreatedBy) }
	, CreateDate { std::move(other.CreateDate) }
{
}

CreateItemGroupInput::~CreateItemGroupInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

CreateItemGroupInput& CreateItemGroupInput::operator=(const CreateItemGroupInput& other)
{
	CreateItemGroupInput value { other };

	std::swap(*this, value);

	return *this;
}

CreateItemGroupInput& CreateItemGroupInput::operator=(CreateItemGroupInput&& other) noexcept
{
	Code = std::move(other.Code);
	Name = std::move(other.Name);
	CreatedBy = std::move(other.CreatedBy);
	CreateDate = std::move(other.CreateDate);

	return *this;
}

UpdateUserFilter::UpdateUserFilter() noexcept
	: Entry {}
	, Code {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

UpdateUserFilter::UpdateUserFilter(
		int EntryArg,
		std::string CodeArg) noexcept
	: Entry { std::move(EntryArg) }
	, Code { std::move(CodeArg) }
{
}

UpdateUserFilter::UpdateUserFilter(const UpdateUserFilter& other)
	: Entry { service::ModifiedArgument<int>::duplicate(other.Entry) }
	, Code { service::ModifiedArgument<std::string>::duplicate(other.Code) }
{
}

UpdateUserFilter::UpdateUserFilter(UpdateUserFilter&& other) noexcept
	: Entry { std::move(other.Entry) }
	, Code { std::move(other.Code) }
{
}

UpdateUserFilter::~UpdateUserFilter()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

UpdateUserFilter& UpdateUserFilter::operator=(const UpdateUserFilter& other)
{
	UpdateUserFilter value { other };

	std::swap(*this, value);

	return *this;
}

UpdateUserFilter& UpdateUserFilter::operator=(UpdateUserFilter&& other) noexcept
{
	Entry = std::move(other.Entry);
	Code = std::move(other.Code);

	return *this;
}

UpdateUserDataInput::UpdateUserDataInput() noexcept
	: Name {}
	, Email {}
	, Phone {}
	, Employee {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

UpdateUserDataInput::UpdateUserDataInput(
		std::string NameArg,
		std::string EmailArg,
		std::string PhoneArg,
		int EmployeeArg) noexcept
	: Name { std::move(NameArg) }
	, Email { std::move(EmailArg) }
	, Phone { std::move(PhoneArg) }
	, Employee { std::move(EmployeeArg) }
{
}

UpdateUserDataInput::UpdateUserDataInput(const UpdateUserDataInput& other)
	: Name { service::ModifiedArgument<std::string>::duplicate(other.Name) }
	, Email { service::ModifiedArgument<std::string>::duplicate(other.Email) }
	, Phone { service::ModifiedArgument<std::string>::duplicate(other.Phone) }
	, Employee { service::ModifiedArgument<int>::duplicate(other.Employee) }
{
}

UpdateUserDataInput::UpdateUserDataInput(UpdateUserDataInput&& other) noexcept
	: Name { std::move(other.Name) }
	, Email { std::move(other.Email) }
	, Phone { std::move(other.Phone) }
	, Employee { std::move(other.Employee) }
{
}

UpdateUserDataInput::~UpdateUserDataInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

UpdateUserDataInput& UpdateUserDataInput::operator=(const UpdateUserDataInput& other)
{
	UpdateUserDataInput value { other };

	std::swap(*this, value);

	return *this;
}

UpdateUserDataInput& UpdateUserDataInput::operator=(UpdateUserDataInput&& other) noexcept
{
	Name = std::move(other.Name);
	Email = std::move(other.Email);
	Phone = std::move(other.Phone);
	Employee = std::move(other.Employee);

	return *this;
}

UpdateItemInput::UpdateItemInput() noexcept
	: Code {}
	, Name {}
	, Description {}
	, Image {}
	, IsActive {}
	, PurchaseItem {}
	, SellItem {}
	, InventoryItem {}
	, Price {}
	, Brand {}
	, Group {}
	, MinStock {}
	, MaxStock {}
	, MinOrder {}
	, MaxOrder {}
	, MinRequest {}
	, MaxRequest {}
	, LastUpdatedBy {}
	, UpdateDate {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

UpdateItemInput::UpdateItemInput(
		std::string CodeArg,
		std::optional<std::string> NameArg,
		std::optional<std::string> DescriptionArg,
		std::optional<std::string> ImageArg,
		std::optional<bool> IsActiveArg,
		std::optional<bool> PurchaseItemArg,
		std::optional<bool> SellItemArg,
		std::optional<bool> InventoryItemArg,
		std::optional<double> PriceArg,
		std::optional<int> BrandArg,
		std::optional<int> GroupArg,
		std::optional<double> MinStockArg,
		std::optional<double> MaxStockArg,
		std::optional<double> MinOrderArg,
		std::optional<double> MaxOrderArg,
		std::optional<double> MinRequestArg,
		std::optional<double> MaxRequestArg,
		int LastUpdatedByArg,
		std::string UpdateDateArg) noexcept
	: Code { std::move(CodeArg) }
	, Name { std::move(NameArg) }
	, Description { std::move(DescriptionArg) }
	, Image { std::move(ImageArg) }
	, IsActive { std::move(IsActiveArg) }
	, PurchaseItem { std::move(PurchaseItemArg) }
	, SellItem { std::move(SellItemArg) }
	, InventoryItem { std::move(InventoryItemArg) }
	, Price { std::move(PriceArg) }
	, Brand { std::move(BrandArg) }
	, Group { std::move(GroupArg) }
	, MinStock { std::move(MinStockArg) }
	, MaxStock { std::move(MaxStockArg) }
	, MinOrder { std::move(MinOrderArg) }
	, MaxOrder { std::move(MaxOrderArg) }
	, MinRequest { std::move(MinRequestArg) }
	, MaxRequest { std::move(MaxRequestArg) }
	, LastUpdatedBy { std::move(LastUpdatedByArg) }
	, UpdateDate { std::move(UpdateDateArg) }
{
}

UpdateItemInput::UpdateItemInput(const UpdateItemInput& other)
	: Code { service::ModifiedArgument<std::string>::duplicate(other.Code) }
	, Name { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Name) }
	, Description { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Description) }
	, Image { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Image) }
	, IsActive { service::ModifiedArgument<bool>::duplicate<service::TypeModifier::Nullable>(other.IsActive) }
	, PurchaseItem { service::ModifiedArgument<bool>::duplicate<service::TypeModifier::Nullable>(other.PurchaseItem) }
	, SellItem { service::ModifiedArgument<bool>::duplicate<service::TypeModifier::Nullable>(other.SellItem) }
	, InventoryItem { service::ModifiedArgument<bool>::duplicate<service::TypeModifier::Nullable>(other.InventoryItem) }
	, Price { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.Price) }
	, Brand { service::ModifiedArgument<int>::duplicate<service::TypeModifier::Nullable>(other.Brand) }
	, Group { service::ModifiedArgument<int>::duplicate<service::TypeModifier::Nullable>(other.Group) }
	, MinStock { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MinStock) }
	, MaxStock { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MaxStock) }
	, MinOrder { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MinOrder) }
	, MaxOrder { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MaxOrder) }
	, MinRequest { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MinRequest) }
	, MaxRequest { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MaxRequest) }
	, LastUpdatedBy { service::ModifiedArgument<int>::duplicate(other.LastUpdatedBy) }
	, UpdateDate { service::ModifiedArgument<std::string>::duplicate(other.UpdateDate) }
{
}

UpdateItemInput::UpdateItemInput(UpdateItemInput&& other) noexcept
	: Code { std::move(other.Code) }
	, Name { std::move(other.Name) }
	, Description { std::move(other.Description) }
	, Image { std::move(other.Image) }
	, IsActive { std::move(other.IsActive) }
	, PurchaseItem { std::move(other.PurchaseItem) }
	, SellItem { std::move(other.SellItem) }
	, InventoryItem { std::move(other.InventoryItem) }
	, Price { std::move(other.Price) }
	, Brand { std::move(other.Brand) }
	, Group { std::move(other.Group) }
	, MinStock { std::move(other.MinStock) }
	, MaxStock { std::move(other.MaxStock) }
	, MinOrder { std::move(other.MinOrder) }
	, MaxOrder { std::move(other.MaxOrder) }
	, MinRequest { std::move(other.MinRequest) }
	, MaxRequest { std::move(other.MaxRequest) }
	, LastUpdatedBy { std::move(other.LastUpdatedBy) }
	, UpdateDate { std::move(other.UpdateDate) }
{
}

UpdateItemInput::~UpdateItemInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

UpdateItemInput& UpdateItemInput::operator=(const UpdateItemInput& other)
{
	UpdateItemInput value { other };

	std::swap(*this, value);

	return *this;
}

UpdateItemInput& UpdateItemInput::operator=(UpdateItemInput&& other) noexcept
{
	Code = std::move(other.Code);
	Name = std::move(other.Name);
	Description = std::move(other.Description);
	Image = std::move(other.Image);
	IsActive = std::move(other.IsActive);
	PurchaseItem = std::move(other.PurchaseItem);
	SellItem = std::move(other.SellItem);
	InventoryItem = std::move(other.InventoryItem);
	Price = std::move(other.Price);
	Brand = std::move(other.Brand);
	Group = std::move(other.Group);
	MinStock = std::move(other.MinStock);
	MaxStock = std::move(other.MaxStock);
	MinOrder = std::move(other.MinOrder);
	MaxOrder = std::move(other.MaxOrder);
	MinRequest = std::move(other.MinRequest);
	MaxRequest = std::move(other.MaxRequest);
	LastUpdatedBy = std::move(other.LastUpdatedBy);
	UpdateDate = std::move(other.UpdateDate);

	return *this;
}

UpdateItemBrandInput::UpdateItemBrandInput() noexcept
	: Code {}
	, Name {}
	, LastUpdatedBy {}
	, UpdateDate {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

UpdateItemBrandInput::UpdateItemBrandInput(
		std::string CodeArg,
		std::string NameArg,
		int LastUpdatedByArg,
		std::string UpdateDateArg) noexcept
	: Code { std::move(CodeArg) }
	, Name { std::move(NameArg) }
	, LastUpdatedBy { std::move(LastUpdatedByArg) }
	, UpdateDate { std::move(UpdateDateArg) }
{
}

UpdateItemBrandInput::UpdateItemBrandInput(const UpdateItemBrandInput& other)
	: Code { service::ModifiedArgument<std::string>::duplicate(other.Code) }
	, Name { service::ModifiedArgument<std::string>::duplicate(other.Name) }
	, LastUpdatedBy { service::ModifiedArgument<int>::duplicate(other.LastUpdatedBy) }
	, UpdateDate { service::ModifiedArgument<std::string>::duplicate(other.UpdateDate) }
{
}

UpdateItemBrandInput::UpdateItemBrandInput(UpdateItemBrandInput&& other) noexcept
	: Code { std::move(other.Code) }
	, Name { std::move(other.Name) }
	, LastUpdatedBy { std::move(other.LastUpdatedBy) }
	, UpdateDate { std::move(other.UpdateDate) }
{
}

UpdateItemBrandInput::~UpdateItemBrandInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

UpdateItemBrandInput& UpdateItemBrandInput::operator=(const UpdateItemBrandInput& other)
{
	UpdateItemBrandInput value { other };

	std::swap(*this, value);

	return *this;
}

UpdateItemBrandInput& UpdateItemBrandInput::operator=(UpdateItemBrandInput&& other) noexcept
{
	Code = std::move(other.Code);
	Name = std::move(other.Name);
	LastUpdatedBy = std::move(other.LastUpdatedBy);
	UpdateDate = std::move(other.UpdateDate);

	return *this;
}

GetUserInput::GetUserInput() noexcept
	: Entry {}
	, Code {}
	, Name {}
	, Email {}
	, Phone {}
	, Employee {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

GetUserInput::GetUserInput(
		std::optional<int> EntryArg,
		std::optional<std::string> CodeArg,
		std::optional<std::string> NameArg,
		std::optional<std::string> EmailArg,
		std::optional<std::string> PhoneArg,
		std::optional<int> EmployeeArg) noexcept
	: Entry { std::move(EntryArg) }
	, Code { std::move(CodeArg) }
	, Name { std::move(NameArg) }
	, Email { std::move(EmailArg) }
	, Phone { std::move(PhoneArg) }
	, Employee { std::move(EmployeeArg) }
{
}

GetUserInput::GetUserInput(const GetUserInput& other)
	: Entry { service::ModifiedArgument<int>::duplicate<service::TypeModifier::Nullable>(other.Entry) }
	, Code { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Code) }
	, Name { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Name) }
	, Email { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Email) }
	, Phone { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Phone) }
	, Employee { service::ModifiedArgument<int>::duplicate<service::TypeModifier::Nullable>(other.Employee) }
{
}

GetUserInput::GetUserInput(GetUserInput&& other) noexcept
	: Entry { std::move(other.Entry) }
	, Code { std::move(other.Code) }
	, Name { std::move(other.Name) }
	, Email { std::move(other.Email) }
	, Phone { std::move(other.Phone) }
	, Employee { std::move(other.Employee) }
{
}

GetUserInput::~GetUserInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

GetUserInput& GetUserInput::operator=(const GetUserInput& other)
{
	GetUserInput value { other };

	std::swap(*this, value);

	return *this;
}

GetUserInput& GetUserInput::operator=(GetUserInput&& other) noexcept
{
	Entry = std::move(other.Entry);
	Code = std::move(other.Code);
	Name = std::move(other.Name);
	Email = std::move(other.Email);
	Phone = std::move(other.Phone);
	Employee = std::move(other.Employee);

	return *this;
}

GetItemInput::GetItemInput() noexcept
	: Entry {}
	, Code {}
	, Name {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

GetItemInput::GetItemInput(
		std::optional<int> EntryArg,
		std::optional<std::string> CodeArg,
		std::optional<std::string> NameArg) noexcept
	: Entry { std::move(EntryArg) }
	, Code { std::move(CodeArg) }
	, Name { std::move(NameArg) }
{
}

GetItemInput::GetItemInput(const GetItemInput& other)
	: Entry { service::ModifiedArgument<int>::duplicate<service::TypeModifier::Nullable>(other.Entry) }
	, Code { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Code) }
	, Name { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Name) }
{
}

GetItemInput::GetItemInput(GetItemInput&& other) noexcept
	: Entry { std::move(other.Entry) }
	, Code { std::move(other.Code) }
	, Name { std::move(other.Name) }
{
}

GetItemInput::~GetItemInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

GetItemInput& GetItemInput::operator=(const GetItemInput& other)
{
	GetItemInput value { other };

	std::swap(*this, value);

	return *this;
}

GetItemInput& GetItemInput::operator=(GetItemInput&& other) noexcept
{
	Entry = std::move(other.Entry);
	Code = std::move(other.Code);
	Name = std::move(other.Name);

	return *this;
}

GetItemGroupInput::GetItemGroupInput() noexcept
	: Code {}
	, Name {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

GetItemGroupInput::GetItemGroupInput(
		std::optional<std::string> CodeArg,
		std::optional<std::string> NameArg) noexcept
	: Code { std::move(CodeArg) }
	, Name { std::move(NameArg) }
{
}

GetItemGroupInput::GetItemGroupInput(const GetItemGroupInput& other)
	: Code { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Code) }
	, Name { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Name) }
{
}

GetItemGroupInput::GetItemGroupInput(GetItemGroupInput&& other) noexcept
	: Code { std::move(other.Code) }
	, Name { std::move(other.Name) }
{
}

GetItemGroupInput::~GetItemGroupInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

GetItemGroupInput& GetItemGroupInput::operator=(const GetItemGroupInput& other)
{
	GetItemGroupInput value { other };

	std::swap(*this, value);

	return *this;
}

GetItemGroupInput& GetItemGroupInput::operator=(GetItemGroupInput&& other) noexcept
{
	Code = std::move(other.Code);
	Name = std::move(other.Name);

	return *this;
}

GetItemBrandInput::GetItemBrandInput() noexcept
	: Code {}
	, Name {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

GetItemBrandInput::GetItemBrandInput(
		std::optional<std::string> CodeArg,
		std::optional<std::string> NameArg) noexcept
	: Code { std::move(CodeArg) }
	, Name { std::move(NameArg) }
{
}

GetItemBrandInput::GetItemBrandInput(const GetItemBrandInput& other)
	: Code { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Code) }
	, Name { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Name) }
{
}

GetItemBrandInput::GetItemBrandInput(GetItemBrandInput&& other) noexcept
	: Code { std::move(other.Code) }
	, Name { std::move(other.Name) }
{
}

GetItemBrandInput::~GetItemBrandInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

GetItemBrandInput& GetItemBrandInput::operator=(const GetItemBrandInput& other)
{
	GetItemBrandInput value { other };

	std::swap(*this, value);

	return *this;
}

GetItemBrandInput& GetItemBrandInput::operator=(GetItemBrandInput&& other) noexcept
{
	Code = std::move(other.Code);
	Name = std::move(other.Name);

	return *this;
}

SearchUsersInput::SearchUsersInput() noexcept
	: AllOff {}
	, AnyOff {}
	, CodeEqualsTo {}
	, CodeContains {}
	, NameEqualsTo {}
	, NameConatins {}
	, EmailEqualsTo {}
	, EmailContains {}
	, PhoneEqualsTo {}
	, PhoneContains {}
	, InactiveUsers {}
	, LockedUsers {}
	, HasEmployee {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

SearchUsersInput::SearchUsersInput(
		bool AllOffArg,
		bool AnyOffArg,
		std::optional<std::string> CodeEqualsToArg,
		std::optional<std::string> CodeContainsArg,
		std::optional<std::string> NameEqualsToArg,
		std::optional<std::string> NameConatinsArg,
		std::optional<std::string> EmailEqualsToArg,
		std::optional<std::string> EmailContainsArg,
		std::optional<std::string> PhoneEqualsToArg,
		std::optional<std::string> PhoneContainsArg,
		std::optional<bool> InactiveUsersArg,
		std::optional<bool> LockedUsersArg,
		std::optional<bool> HasEmployeeArg) noexcept
	: AllOff { std::move(AllOffArg) }
	, AnyOff { std::move(AnyOffArg) }
	, CodeEqualsTo { std::move(CodeEqualsToArg) }
	, CodeContains { std::move(CodeContainsArg) }
	, NameEqualsTo { std::move(NameEqualsToArg) }
	, NameConatins { std::move(NameConatinsArg) }
	, EmailEqualsTo { std::move(EmailEqualsToArg) }
	, EmailContains { std::move(EmailContainsArg) }
	, PhoneEqualsTo { std::move(PhoneEqualsToArg) }
	, PhoneContains { std::move(PhoneContainsArg) }
	, InactiveUsers { std::move(InactiveUsersArg) }
	, LockedUsers { std::move(LockedUsersArg) }
	, HasEmployee { std::move(HasEmployeeArg) }
{
}

SearchUsersInput::SearchUsersInput(const SearchUsersInput& other)
	: AllOff { service::ModifiedArgument<bool>::duplicate(other.AllOff) }
	, AnyOff { service::ModifiedArgument<bool>::duplicate(other.AnyOff) }
	, CodeEqualsTo { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.CodeEqualsTo) }
	, CodeContains { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.CodeContains) }
	, NameEqualsTo { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.NameEqualsTo) }
	, NameConatins { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.NameConatins) }
	, EmailEqualsTo { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.EmailEqualsTo) }
	, EmailContains { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.EmailContains) }
	, PhoneEqualsTo { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.PhoneEqualsTo) }
	, PhoneContains { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.PhoneContains) }
	, InactiveUsers { service::ModifiedArgument<bool>::duplicate<service::TypeModifier::Nullable>(other.InactiveUsers) }
	, LockedUsers { service::ModifiedArgument<bool>::duplicate<service::TypeModifier::Nullable>(other.LockedUsers) }
	, HasEmployee { service::ModifiedArgument<bool>::duplicate<service::TypeModifier::Nullable>(other.HasEmployee) }
{
}

SearchUsersInput::SearchUsersInput(SearchUsersInput&& other) noexcept
	: AllOff { std::move(other.AllOff) }
	, AnyOff { std::move(other.AnyOff) }
	, CodeEqualsTo { std::move(other.CodeEqualsTo) }
	, CodeContains { std::move(other.CodeContains) }
	, NameEqualsTo { std::move(other.NameEqualsTo) }
	, NameConatins { std::move(other.NameConatins) }
	, EmailEqualsTo { std::move(other.EmailEqualsTo) }
	, EmailContains { std::move(other.EmailContains) }
	, PhoneEqualsTo { std::move(other.PhoneEqualsTo) }
	, PhoneContains { std::move(other.PhoneContains) }
	, InactiveUsers { std::move(other.InactiveUsers) }
	, LockedUsers { std::move(other.LockedUsers) }
	, HasEmployee { std::move(other.HasEmployee) }
{
}

SearchUsersInput::~SearchUsersInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

SearchUsersInput& SearchUsersInput::operator=(const SearchUsersInput& other)
{
	SearchUsersInput value { other };

	std::swap(*this, value);

	return *this;
}

SearchUsersInput& SearchUsersInput::operator=(SearchUsersInput&& other) noexcept
{
	AllOff = std::move(other.AllOff);
	AnyOff = std::move(other.AnyOff);
	CodeEqualsTo = std::move(other.CodeEqualsTo);
	CodeContains = std::move(other.CodeContains);
	NameEqualsTo = std::move(other.NameEqualsTo);
	NameConatins = std::move(other.NameConatins);
	EmailEqualsTo = std::move(other.EmailEqualsTo);
	EmailContains = std::move(other.EmailContains);
	PhoneEqualsTo = std::move(other.PhoneEqualsTo);
	PhoneContains = std::move(other.PhoneContains);
	InactiveUsers = std::move(other.InactiveUsers);
	LockedUsers = std::move(other.LockedUsers);
	HasEmployee = std::move(other.HasEmployee);

	return *this;
}

SearchItemsInput::SearchItemsInput() noexcept
	: CodeEqualsTo {}
	, CodeContains {}
	, NameEqualsTo {}
	, NameContains {}
	, DescriptionEqualsTo {}
	, DescriptionContains {}
	, IsActive {}
	, PurchaseItem {}
	, SellItem {}
	, InventoryItem {}
	, Price {}
	, OnHandEqualsTo {}
	, OnHandGreaterThan {}
	, OnHandLessThan {}
	, OnRequestEqualsTo {}
	, OnRequestGreaterThan {}
	, OnRequestLessThan {}
	, OnOrderEqualsTo {}
	, OnOrderGreaterThan {}
	, OnOrderLessThan {}
	, MinStockEqualsTo {}
	, MinStockGreaterThan {}
	, MinStockLessThan {}
	, MaxStockEqualsTo {}
	, MaxStockGreaterThan {}
	, MaxStockLessThan {}
	, MinOrderEqualsTo {}
	, MinOrderGreaterThan {}
	, MinOrderLessThan {}
	, MaxOrderEqualsTo {}
	, MaxOrderGreaterThan {}
	, MaxOrderLessThan {}
	, MinRequestEqualsTo {}
	, MinRequestGreaterThan {}
	, MinRequestLessThan {}
	, MaxReqeuestEqualsTo {}
	, MaxRequestGreaterThan {}
	, MaxRequestLessThan {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

SearchItemsInput::SearchItemsInput(
		std::optional<std::string> CodeEqualsToArg,
		std::optional<std::string> CodeContainsArg,
		std::optional<std::string> NameEqualsToArg,
		std::optional<std::string> NameContainsArg,
		std::optional<std::string> DescriptionEqualsToArg,
		std::optional<std::string> DescriptionContainsArg,
		std::optional<bool> IsActiveArg,
		std::optional<bool> PurchaseItemArg,
		std::optional<bool> SellItemArg,
		std::optional<bool> InventoryItemArg,
		std::optional<double> PriceArg,
		std::optional<double> OnHandEqualsToArg,
		std::optional<double> OnHandGreaterThanArg,
		std::optional<double> OnHandLessThanArg,
		std::optional<double> OnRequestEqualsToArg,
		std::optional<double> OnRequestGreaterThanArg,
		std::optional<double> OnRequestLessThanArg,
		std::optional<double> OnOrderEqualsToArg,
		std::optional<double> OnOrderGreaterThanArg,
		std::optional<double> OnOrderLessThanArg,
		std::optional<double> MinStockEqualsToArg,
		std::optional<double> MinStockGreaterThanArg,
		std::optional<double> MinStockLessThanArg,
		std::optional<double> MaxStockEqualsToArg,
		std::optional<double> MaxStockGreaterThanArg,
		std::optional<double> MaxStockLessThanArg,
		std::optional<double> MinOrderEqualsToArg,
		std::optional<double> MinOrderGreaterThanArg,
		std::optional<double> MinOrderLessThanArg,
		std::optional<double> MaxOrderEqualsToArg,
		std::optional<double> MaxOrderGreaterThanArg,
		std::optional<double> MaxOrderLessThanArg,
		std::optional<double> MinRequestEqualsToArg,
		std::optional<double> MinRequestGreaterThanArg,
		std::optional<double> MinRequestLessThanArg,
		std::optional<double> MaxReqeuestEqualsToArg,
		std::optional<double> MaxRequestGreaterThanArg,
		std::optional<double> MaxRequestLessThanArg) noexcept
	: CodeEqualsTo { std::move(CodeEqualsToArg) }
	, CodeContains { std::move(CodeContainsArg) }
	, NameEqualsTo { std::move(NameEqualsToArg) }
	, NameContains { std::move(NameContainsArg) }
	, DescriptionEqualsTo { std::move(DescriptionEqualsToArg) }
	, DescriptionContains { std::move(DescriptionContainsArg) }
	, IsActive { std::move(IsActiveArg) }
	, PurchaseItem { std::move(PurchaseItemArg) }
	, SellItem { std::move(SellItemArg) }
	, InventoryItem { std::move(InventoryItemArg) }
	, Price { std::move(PriceArg) }
	, OnHandEqualsTo { std::move(OnHandEqualsToArg) }
	, OnHandGreaterThan { std::move(OnHandGreaterThanArg) }
	, OnHandLessThan { std::move(OnHandLessThanArg) }
	, OnRequestEqualsTo { std::move(OnRequestEqualsToArg) }
	, OnRequestGreaterThan { std::move(OnRequestGreaterThanArg) }
	, OnRequestLessThan { std::move(OnRequestLessThanArg) }
	, OnOrderEqualsTo { std::move(OnOrderEqualsToArg) }
	, OnOrderGreaterThan { std::move(OnOrderGreaterThanArg) }
	, OnOrderLessThan { std::move(OnOrderLessThanArg) }
	, MinStockEqualsTo { std::move(MinStockEqualsToArg) }
	, MinStockGreaterThan { std::move(MinStockGreaterThanArg) }
	, MinStockLessThan { std::move(MinStockLessThanArg) }
	, MaxStockEqualsTo { std::move(MaxStockEqualsToArg) }
	, MaxStockGreaterThan { std::move(MaxStockGreaterThanArg) }
	, MaxStockLessThan { std::move(MaxStockLessThanArg) }
	, MinOrderEqualsTo { std::move(MinOrderEqualsToArg) }
	, MinOrderGreaterThan { std::move(MinOrderGreaterThanArg) }
	, MinOrderLessThan { std::move(MinOrderLessThanArg) }
	, MaxOrderEqualsTo { std::move(MaxOrderEqualsToArg) }
	, MaxOrderGreaterThan { std::move(MaxOrderGreaterThanArg) }
	, MaxOrderLessThan { std::move(MaxOrderLessThanArg) }
	, MinRequestEqualsTo { std::move(MinRequestEqualsToArg) }
	, MinRequestGreaterThan { std::move(MinRequestGreaterThanArg) }
	, MinRequestLessThan { std::move(MinRequestLessThanArg) }
	, MaxReqeuestEqualsTo { std::move(MaxReqeuestEqualsToArg) }
	, MaxRequestGreaterThan { std::move(MaxRequestGreaterThanArg) }
	, MaxRequestLessThan { std::move(MaxRequestLessThanArg) }
{
}

SearchItemsInput::SearchItemsInput(const SearchItemsInput& other)
	: CodeEqualsTo { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.CodeEqualsTo) }
	, CodeContains { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.CodeContains) }
	, NameEqualsTo { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.NameEqualsTo) }
	, NameContains { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.NameContains) }
	, DescriptionEqualsTo { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.DescriptionEqualsTo) }
	, DescriptionContains { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.DescriptionContains) }
	, IsActive { service::ModifiedArgument<bool>::duplicate<service::TypeModifier::Nullable>(other.IsActive) }
	, PurchaseItem { service::ModifiedArgument<bool>::duplicate<service::TypeModifier::Nullable>(other.PurchaseItem) }
	, SellItem { service::ModifiedArgument<bool>::duplicate<service::TypeModifier::Nullable>(other.SellItem) }
	, InventoryItem { service::ModifiedArgument<bool>::duplicate<service::TypeModifier::Nullable>(other.InventoryItem) }
	, Price { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.Price) }
	, OnHandEqualsTo { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.OnHandEqualsTo) }
	, OnHandGreaterThan { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.OnHandGreaterThan) }
	, OnHandLessThan { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.OnHandLessThan) }
	, OnRequestEqualsTo { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.OnRequestEqualsTo) }
	, OnRequestGreaterThan { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.OnRequestGreaterThan) }
	, OnRequestLessThan { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.OnRequestLessThan) }
	, OnOrderEqualsTo { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.OnOrderEqualsTo) }
	, OnOrderGreaterThan { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.OnOrderGreaterThan) }
	, OnOrderLessThan { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.OnOrderLessThan) }
	, MinStockEqualsTo { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MinStockEqualsTo) }
	, MinStockGreaterThan { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MinStockGreaterThan) }
	, MinStockLessThan { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MinStockLessThan) }
	, MaxStockEqualsTo { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MaxStockEqualsTo) }
	, MaxStockGreaterThan { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MaxStockGreaterThan) }
	, MaxStockLessThan { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MaxStockLessThan) }
	, MinOrderEqualsTo { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MinOrderEqualsTo) }
	, MinOrderGreaterThan { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MinOrderGreaterThan) }
	, MinOrderLessThan { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MinOrderLessThan) }
	, MaxOrderEqualsTo { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MaxOrderEqualsTo) }
	, MaxOrderGreaterThan { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MaxOrderGreaterThan) }
	, MaxOrderLessThan { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MaxOrderLessThan) }
	, MinRequestEqualsTo { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MinRequestEqualsTo) }
	, MinRequestGreaterThan { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MinRequestGreaterThan) }
	, MinRequestLessThan { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MinRequestLessThan) }
	, MaxReqeuestEqualsTo { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MaxReqeuestEqualsTo) }
	, MaxRequestGreaterThan { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MaxRequestGreaterThan) }
	, MaxRequestLessThan { service::ModifiedArgument<double>::duplicate<service::TypeModifier::Nullable>(other.MaxRequestLessThan) }
{
}

SearchItemsInput::SearchItemsInput(SearchItemsInput&& other) noexcept
	: CodeEqualsTo { std::move(other.CodeEqualsTo) }
	, CodeContains { std::move(other.CodeContains) }
	, NameEqualsTo { std::move(other.NameEqualsTo) }
	, NameContains { std::move(other.NameContains) }
	, DescriptionEqualsTo { std::move(other.DescriptionEqualsTo) }
	, DescriptionContains { std::move(other.DescriptionContains) }
	, IsActive { std::move(other.IsActive) }
	, PurchaseItem { std::move(other.PurchaseItem) }
	, SellItem { std::move(other.SellItem) }
	, InventoryItem { std::move(other.InventoryItem) }
	, Price { std::move(other.Price) }
	, OnHandEqualsTo { std::move(other.OnHandEqualsTo) }
	, OnHandGreaterThan { std::move(other.OnHandGreaterThan) }
	, OnHandLessThan { std::move(other.OnHandLessThan) }
	, OnRequestEqualsTo { std::move(other.OnRequestEqualsTo) }
	, OnRequestGreaterThan { std::move(other.OnRequestGreaterThan) }
	, OnRequestLessThan { std::move(other.OnRequestLessThan) }
	, OnOrderEqualsTo { std::move(other.OnOrderEqualsTo) }
	, OnOrderGreaterThan { std::move(other.OnOrderGreaterThan) }
	, OnOrderLessThan { std::move(other.OnOrderLessThan) }
	, MinStockEqualsTo { std::move(other.MinStockEqualsTo) }
	, MinStockGreaterThan { std::move(other.MinStockGreaterThan) }
	, MinStockLessThan { std::move(other.MinStockLessThan) }
	, MaxStockEqualsTo { std::move(other.MaxStockEqualsTo) }
	, MaxStockGreaterThan { std::move(other.MaxStockGreaterThan) }
	, MaxStockLessThan { std::move(other.MaxStockLessThan) }
	, MinOrderEqualsTo { std::move(other.MinOrderEqualsTo) }
	, MinOrderGreaterThan { std::move(other.MinOrderGreaterThan) }
	, MinOrderLessThan { std::move(other.MinOrderLessThan) }
	, MaxOrderEqualsTo { std::move(other.MaxOrderEqualsTo) }
	, MaxOrderGreaterThan { std::move(other.MaxOrderGreaterThan) }
	, MaxOrderLessThan { std::move(other.MaxOrderLessThan) }
	, MinRequestEqualsTo { std::move(other.MinRequestEqualsTo) }
	, MinRequestGreaterThan { std::move(other.MinRequestGreaterThan) }
	, MinRequestLessThan { std::move(other.MinRequestLessThan) }
	, MaxReqeuestEqualsTo { std::move(other.MaxReqeuestEqualsTo) }
	, MaxRequestGreaterThan { std::move(other.MaxRequestGreaterThan) }
	, MaxRequestLessThan { std::move(other.MaxRequestLessThan) }
{
}

SearchItemsInput::~SearchItemsInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

SearchItemsInput& SearchItemsInput::operator=(const SearchItemsInput& other)
{
	SearchItemsInput value { other };

	std::swap(*this, value);

	return *this;
}

SearchItemsInput& SearchItemsInput::operator=(SearchItemsInput&& other) noexcept
{
	CodeEqualsTo = std::move(other.CodeEqualsTo);
	CodeContains = std::move(other.CodeContains);
	NameEqualsTo = std::move(other.NameEqualsTo);
	NameContains = std::move(other.NameContains);
	DescriptionEqualsTo = std::move(other.DescriptionEqualsTo);
	DescriptionContains = std::move(other.DescriptionContains);
	IsActive = std::move(other.IsActive);
	PurchaseItem = std::move(other.PurchaseItem);
	SellItem = std::move(other.SellItem);
	InventoryItem = std::move(other.InventoryItem);
	Price = std::move(other.Price);
	OnHandEqualsTo = std::move(other.OnHandEqualsTo);
	OnHandGreaterThan = std::move(other.OnHandGreaterThan);
	OnHandLessThan = std::move(other.OnHandLessThan);
	OnRequestEqualsTo = std::move(other.OnRequestEqualsTo);
	OnRequestGreaterThan = std::move(other.OnRequestGreaterThan);
	OnRequestLessThan = std::move(other.OnRequestLessThan);
	OnOrderEqualsTo = std::move(other.OnOrderEqualsTo);
	OnOrderGreaterThan = std::move(other.OnOrderGreaterThan);
	OnOrderLessThan = std::move(other.OnOrderLessThan);
	MinStockEqualsTo = std::move(other.MinStockEqualsTo);
	MinStockGreaterThan = std::move(other.MinStockGreaterThan);
	MinStockLessThan = std::move(other.MinStockLessThan);
	MaxStockEqualsTo = std::move(other.MaxStockEqualsTo);
	MaxStockGreaterThan = std::move(other.MaxStockGreaterThan);
	MaxStockLessThan = std::move(other.MaxStockLessThan);
	MinOrderEqualsTo = std::move(other.MinOrderEqualsTo);
	MinOrderGreaterThan = std::move(other.MinOrderGreaterThan);
	MinOrderLessThan = std::move(other.MinOrderLessThan);
	MaxOrderEqualsTo = std::move(other.MaxOrderEqualsTo);
	MaxOrderGreaterThan = std::move(other.MaxOrderGreaterThan);
	MaxOrderLessThan = std::move(other.MaxOrderLessThan);
	MinRequestEqualsTo = std::move(other.MinRequestEqualsTo);
	MinRequestGreaterThan = std::move(other.MinRequestGreaterThan);
	MinRequestLessThan = std::move(other.MinRequestLessThan);
	MaxReqeuestEqualsTo = std::move(other.MaxReqeuestEqualsTo);
	MaxRequestGreaterThan = std::move(other.MaxRequestGreaterThan);
	MaxRequestLessThan = std::move(other.MaxRequestLessThan);

	return *this;
}

SearchItemGroupsInput::SearchItemGroupsInput() noexcept
	: NameEqualsTo {}
	, NameContains {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

SearchItemGroupsInput::SearchItemGroupsInput(
		std::optional<std::string> NameEqualsToArg,
		std::optional<std::string> NameContainsArg) noexcept
	: NameEqualsTo { std::move(NameEqualsToArg) }
	, NameContains { std::move(NameContainsArg) }
{
}

SearchItemGroupsInput::SearchItemGroupsInput(const SearchItemGroupsInput& other)
	: NameEqualsTo { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.NameEqualsTo) }
	, NameContains { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.NameContains) }
{
}

SearchItemGroupsInput::SearchItemGroupsInput(SearchItemGroupsInput&& other) noexcept
	: NameEqualsTo { std::move(other.NameEqualsTo) }
	, NameContains { std::move(other.NameContains) }
{
}

SearchItemGroupsInput::~SearchItemGroupsInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

SearchItemGroupsInput& SearchItemGroupsInput::operator=(const SearchItemGroupsInput& other)
{
	SearchItemGroupsInput value { other };

	std::swap(*this, value);

	return *this;
}

SearchItemGroupsInput& SearchItemGroupsInput::operator=(SearchItemGroupsInput&& other) noexcept
{
	NameEqualsTo = std::move(other.NameEqualsTo);
	NameContains = std::move(other.NameContains);

	return *this;
}

SearchItemBrandsInput::SearchItemBrandsInput() noexcept
	: NameEqualsTo {}
	, NameContains {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

SearchItemBrandsInput::SearchItemBrandsInput(
		std::optional<std::string> NameEqualsToArg,
		std::optional<std::string> NameContainsArg) noexcept
	: NameEqualsTo { std::move(NameEqualsToArg) }
	, NameContains { std::move(NameContainsArg) }
{
}

SearchItemBrandsInput::SearchItemBrandsInput(const SearchItemBrandsInput& other)
	: NameEqualsTo { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.NameEqualsTo) }
	, NameContains { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.NameContains) }
{
}

SearchItemBrandsInput::SearchItemBrandsInput(SearchItemBrandsInput&& other) noexcept
	: NameEqualsTo { std::move(other.NameEqualsTo) }
	, NameContains { std::move(other.NameContains) }
{
}

SearchItemBrandsInput::~SearchItemBrandsInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

SearchItemBrandsInput& SearchItemBrandsInput::operator=(const SearchItemBrandsInput& other)
{
	SearchItemBrandsInput value { other };

	std::swap(*this, value);

	return *this;
}

SearchItemBrandsInput& SearchItemBrandsInput::operator=(SearchItemBrandsInput&& other) noexcept
{
	NameEqualsTo = std::move(other.NameEqualsTo);
	NameContains = std::move(other.NameContains);

	return *this;
}

ChangePasswordInput::ChangePasswordInput() noexcept
	: Entry {}
	, Code {}
	, OldPassword {}
	, NewPassword {}
	, UpdateDate {}
	, UpdatedBy {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

ChangePasswordInput::ChangePasswordInput(
		std::optional<int> EntryArg,
		std::optional<std::string> CodeArg,
		std::string OldPasswordArg,
		std::string NewPasswordArg,
		std::string UpdateDateArg,
		int UpdatedByArg) noexcept
	: Entry { std::move(EntryArg) }
	, Code { std::move(CodeArg) }
	, OldPassword { std::move(OldPasswordArg) }
	, NewPassword { std::move(NewPasswordArg) }
	, UpdateDate { std::move(UpdateDateArg) }
	, UpdatedBy { std::move(UpdatedByArg) }
{
}

ChangePasswordInput::ChangePasswordInput(const ChangePasswordInput& other)
	: Entry { service::ModifiedArgument<int>::duplicate<service::TypeModifier::Nullable>(other.Entry) }
	, Code { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Code) }
	, OldPassword { service::ModifiedArgument<std::string>::duplicate(other.OldPassword) }
	, NewPassword { service::ModifiedArgument<std::string>::duplicate(other.NewPassword) }
	, UpdateDate { service::ModifiedArgument<std::string>::duplicate(other.UpdateDate) }
	, UpdatedBy { service::ModifiedArgument<int>::duplicate(other.UpdatedBy) }
{
}

ChangePasswordInput::ChangePasswordInput(ChangePasswordInput&& other) noexcept
	: Entry { std::move(other.Entry) }
	, Code { std::move(other.Code) }
	, OldPassword { std::move(other.OldPassword) }
	, NewPassword { std::move(other.NewPassword) }
	, UpdateDate { std::move(other.UpdateDate) }
	, UpdatedBy { std::move(other.UpdatedBy) }
{
}

ChangePasswordInput::~ChangePasswordInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

ChangePasswordInput& ChangePasswordInput::operator=(const ChangePasswordInput& other)
{
	ChangePasswordInput value { other };

	std::swap(*this, value);

	return *this;
}

ChangePasswordInput& ChangePasswordInput::operator=(ChangePasswordInput&& other) noexcept
{
	Entry = std::move(other.Entry);
	Code = std::move(other.Code);
	OldPassword = std::move(other.OldPassword);
	NewPassword = std::move(other.NewPassword);
	UpdateDate = std::move(other.UpdateDate);
	UpdatedBy = std::move(other.UpdatedBy);

	return *this;
}

UpdateUserPoliciesInput::UpdateUserPoliciesInput() noexcept
	: Entry {}
	, Code {}
	, IsActive {}
	, IsLocked {}
	, SuperUser {}
	, ChangePasswordNextLogin {}
	, PasswordNeverExpires {}
	, UpdateDate {}
	, UpdatedBy {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

UpdateUserPoliciesInput::UpdateUserPoliciesInput(
		int EntryArg,
		std::string CodeArg,
		bool IsActiveArg,
		bool IsLockedArg,
		bool SuperUserArg,
		bool ChangePasswordNextLoginArg,
		bool PasswordNeverExpiresArg,
		std::string UpdateDateArg,
		int UpdatedByArg) noexcept
	: Entry { std::move(EntryArg) }
	, Code { std::move(CodeArg) }
	, IsActive { std::move(IsActiveArg) }
	, IsLocked { std::move(IsLockedArg) }
	, SuperUser { std::move(SuperUserArg) }
	, ChangePasswordNextLogin { std::move(ChangePasswordNextLoginArg) }
	, PasswordNeverExpires { std::move(PasswordNeverExpiresArg) }
	, UpdateDate { std::move(UpdateDateArg) }
	, UpdatedBy { std::move(UpdatedByArg) }
{
}

UpdateUserPoliciesInput::UpdateUserPoliciesInput(const UpdateUserPoliciesInput& other)
	: Entry { service::ModifiedArgument<int>::duplicate(other.Entry) }
	, Code { service::ModifiedArgument<std::string>::duplicate(other.Code) }
	, IsActive { service::ModifiedArgument<bool>::duplicate(other.IsActive) }
	, IsLocked { service::ModifiedArgument<bool>::duplicate(other.IsLocked) }
	, SuperUser { service::ModifiedArgument<bool>::duplicate(other.SuperUser) }
	, ChangePasswordNextLogin { service::ModifiedArgument<bool>::duplicate(other.ChangePasswordNextLogin) }
	, PasswordNeverExpires { service::ModifiedArgument<bool>::duplicate(other.PasswordNeverExpires) }
	, UpdateDate { service::ModifiedArgument<std::string>::duplicate(other.UpdateDate) }
	, UpdatedBy { service::ModifiedArgument<int>::duplicate(other.UpdatedBy) }
{
}

UpdateUserPoliciesInput::UpdateUserPoliciesInput(UpdateUserPoliciesInput&& other) noexcept
	: Entry { std::move(other.Entry) }
	, Code { std::move(other.Code) }
	, IsActive { std::move(other.IsActive) }
	, IsLocked { std::move(other.IsLocked) }
	, SuperUser { std::move(other.SuperUser) }
	, ChangePasswordNextLogin { std::move(other.ChangePasswordNextLogin) }
	, PasswordNeverExpires { std::move(other.PasswordNeverExpires) }
	, UpdateDate { std::move(other.UpdateDate) }
	, UpdatedBy { std::move(other.UpdatedBy) }
{
}

UpdateUserPoliciesInput::~UpdateUserPoliciesInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

UpdateUserPoliciesInput& UpdateUserPoliciesInput::operator=(const UpdateUserPoliciesInput& other)
{
	UpdateUserPoliciesInput value { other };

	std::swap(*this, value);

	return *this;
}

UpdateUserPoliciesInput& UpdateUserPoliciesInput::operator=(UpdateUserPoliciesInput&& other) noexcept
{
	Entry = std::move(other.Entry);
	Code = std::move(other.Code);
	IsActive = std::move(other.IsActive);
	IsLocked = std::move(other.IsLocked);
	SuperUser = std::move(other.SuperUser);
	ChangePasswordNextLogin = std::move(other.ChangePasswordNextLogin);
	PasswordNeverExpires = std::move(other.PasswordNeverExpires);
	UpdateDate = std::move(other.UpdateDate);
	UpdatedBy = std::move(other.UpdatedBy);

	return *this;
}

UpdateItemGroupInput::UpdateItemGroupInput() noexcept
	: Code {}
	, Name {}
	, LastUpdatedBy {}
	, UpdateDate {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

UpdateItemGroupInput::UpdateItemGroupInput(
		std::string CodeArg,
		std::string NameArg,
		int LastUpdatedByArg,
		std::string UpdateDateArg) noexcept
	: Code { std::move(CodeArg) }
	, Name { std::move(NameArg) }
	, LastUpdatedBy { std::move(LastUpdatedByArg) }
	, UpdateDate { std::move(UpdateDateArg) }
{
}

UpdateItemGroupInput::UpdateItemGroupInput(const UpdateItemGroupInput& other)
	: Code { service::ModifiedArgument<std::string>::duplicate(other.Code) }
	, Name { service::ModifiedArgument<std::string>::duplicate(other.Name) }
	, LastUpdatedBy { service::ModifiedArgument<int>::duplicate(other.LastUpdatedBy) }
	, UpdateDate { service::ModifiedArgument<std::string>::duplicate(other.UpdateDate) }
{
}

UpdateItemGroupInput::UpdateItemGroupInput(UpdateItemGroupInput&& other) noexcept
	: Code { std::move(other.Code) }
	, Name { std::move(other.Name) }
	, LastUpdatedBy { std::move(other.LastUpdatedBy) }
	, UpdateDate { std::move(other.UpdateDate) }
{
}

UpdateItemGroupInput::~UpdateItemGroupInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

UpdateItemGroupInput& UpdateItemGroupInput::operator=(const UpdateItemGroupInput& other)
{
	UpdateItemGroupInput value { other };

	std::swap(*this, value);

	return *this;
}

UpdateItemGroupInput& UpdateItemGroupInput::operator=(UpdateItemGroupInput&& other) noexcept
{
	Code = std::move(other.Code);
	Name = std::move(other.Name);
	LastUpdatedBy = std::move(other.LastUpdatedBy);
	UpdateDate = std::move(other.UpdateDate);

	return *this;
}

SessionParams::SessionParams() noexcept
	: Code {}
	, Email {}
	, Phone {}
	, StartDate {}
	, DeviceIP {}
	, HostName {}
	, Password {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

SessionParams::SessionParams(
		std::optional<std::string> CodeArg,
		std::optional<std::string> EmailArg,
		std::optional<std::string> PhoneArg,
		std::string StartDateArg,
		std::string DeviceIPArg,
		std::string HostNameArg,
		std::string PasswordArg) noexcept
	: Code { std::move(CodeArg) }
	, Email { std::move(EmailArg) }
	, Phone { std::move(PhoneArg) }
	, StartDate { std::move(StartDateArg) }
	, DeviceIP { std::move(DeviceIPArg) }
	, HostName { std::move(HostNameArg) }
	, Password { std::move(PasswordArg) }
{
}

SessionParams::SessionParams(const SessionParams& other)
	: Code { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Code) }
	, Email { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Email) }
	, Phone { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Phone) }
	, StartDate { service::ModifiedArgument<std::string>::duplicate(other.StartDate) }
	, DeviceIP { service::ModifiedArgument<std::string>::duplicate(other.DeviceIP) }
	, HostName { service::ModifiedArgument<std::string>::duplicate(other.HostName) }
	, Password { service::ModifiedArgument<std::string>::duplicate(other.Password) }
{
}

SessionParams::SessionParams(SessionParams&& other) noexcept
	: Code { std::move(other.Code) }
	, Email { std::move(other.Email) }
	, Phone { std::move(other.Phone) }
	, StartDate { std::move(other.StartDate) }
	, DeviceIP { std::move(other.DeviceIP) }
	, HostName { std::move(other.HostName) }
	, Password { std::move(other.Password) }
{
}

SessionParams::~SessionParams()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

SessionParams& SessionParams::operator=(const SessionParams& other)
{
	SessionParams value { other };

	std::swap(*this, value);

	return *this;
}

SessionParams& SessionParams::operator=(SessionParams&& other) noexcept
{
	Code = std::move(other.Code);
	Email = std::move(other.Email);
	Phone = std::move(other.Phone);
	StartDate = std::move(other.StartDate);
	DeviceIP = std::move(other.DeviceIP);
	HostName = std::move(other.HostName);
	Password = std::move(other.Password);

	return *this;
}

LogoutParams::LogoutParams() noexcept
	: SessionUUID {}
	, EndDate {}
	, Reason {}
	, Message {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

LogoutParams::LogoutParams(
		std::string SessionUUIDArg,
		std::string EndDateArg,
		LogoutReason ReasonArg,
		std::optional<std::string> MessageArg) noexcept
	: SessionUUID { std::move(SessionUUIDArg) }
	, EndDate { std::move(EndDateArg) }
	, Reason { std::move(ReasonArg) }
	, Message { std::move(MessageArg) }
{
}

LogoutParams::LogoutParams(const LogoutParams& other)
	: SessionUUID { service::ModifiedArgument<std::string>::duplicate(other.SessionUUID) }
	, EndDate { service::ModifiedArgument<std::string>::duplicate(other.EndDate) }
	, Reason { service::ModifiedArgument<LogoutReason>::duplicate(other.Reason) }
	, Message { service::ModifiedArgument<std::string>::duplicate<service::TypeModifier::Nullable>(other.Message) }
{
}

LogoutParams::LogoutParams(LogoutParams&& other) noexcept
	: SessionUUID { std::move(other.SessionUUID) }
	, EndDate { std::move(other.EndDate) }
	, Reason { std::move(other.Reason) }
	, Message { std::move(other.Message) }
{
}

LogoutParams::~LogoutParams()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

LogoutParams& LogoutParams::operator=(const LogoutParams& other)
{
	LogoutParams value { other };

	std::swap(*this, value);

	return *this;
}

LogoutParams& LogoutParams::operator=(LogoutParams&& other) noexcept
{
	SessionUUID = std::move(other.SessionUUID);
	EndDate = std::move(other.EndDate);
	Reason = std::move(other.Reason);
	Message = std::move(other.Message);

	return *this;
}

UpdateUserInput::UpdateUserInput() noexcept
	: Where {}
	, Data {}
	, UpdateDate {}
	, UpdatedBy {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

UpdateUserInput::UpdateUserInput(
		UpdateUserFilter WhereArg,
		UpdateUserDataInput DataArg,
		std::string UpdateDateArg,
		int UpdatedByArg) noexcept
	: Where { std::move(WhereArg) }
	, Data { std::move(DataArg) }
	, UpdateDate { std::move(UpdateDateArg) }
	, UpdatedBy { std::move(UpdatedByArg) }
{
}

UpdateUserInput::UpdateUserInput(const UpdateUserInput& other)
	: Where { service::ModifiedArgument<UpdateUserFilter>::duplicate(other.Where) }
	, Data { service::ModifiedArgument<UpdateUserDataInput>::duplicate(other.Data) }
	, UpdateDate { service::ModifiedArgument<std::string>::duplicate(other.UpdateDate) }
	, UpdatedBy { service::ModifiedArgument<int>::duplicate(other.UpdatedBy) }
{
}

UpdateUserInput::UpdateUserInput(UpdateUserInput&& other) noexcept
	: Where { std::move(other.Where) }
	, Data { std::move(other.Data) }
	, UpdateDate { std::move(other.UpdateDate) }
	, UpdatedBy { std::move(other.UpdatedBy) }
{
}

UpdateUserInput::~UpdateUserInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

UpdateUserInput& UpdateUserInput::operator=(const UpdateUserInput& other)
{
	UpdateUserInput value { other };

	std::swap(*this, value);

	return *this;
}

UpdateUserInput& UpdateUserInput::operator=(UpdateUserInput&& other) noexcept
{
	Where = std::move(other.Where);
	Data = std::move(other.Data);
	UpdateDate = std::move(other.UpdateDate);
	UpdatedBy = std::move(other.UpdatedBy);

	return *this;
}

Operations::Operations(std::shared_ptr<object::Query> query, std::shared_ptr<object::Mutation> mutation)
	: service::Request({
		{ service::strQuery, query },
		{ service::strMutation, mutation }
	}, GetSchema())
	, _query(std::move(query))
	, _mutation(std::move(mutation))
{
}

void AddTypesToSchema(const std::shared_ptr<schema::Schema>& schema)
{
	auto typeLogoutReason = schema::EnumType::Make(R"gql(LogoutReason)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(LogoutReason)gql"sv, typeLogoutReason);
	auto typeCreateUserInput = schema::InputObjectType::Make(R"gql(CreateUserInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(CreateUserInput)gql"sv, typeCreateUserInput);
	auto typeCreateItemInput = schema::InputObjectType::Make(R"gql(CreateItemInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(CreateItemInput)gql"sv, typeCreateItemInput);
	auto typeCreateItemBrandInput = schema::InputObjectType::Make(R"gql(CreateItemBrandInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(CreateItemBrandInput)gql"sv, typeCreateItemBrandInput);
	auto typeCreateItemGroupInput = schema::InputObjectType::Make(R"gql(CreateItemGroupInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(CreateItemGroupInput)gql"sv, typeCreateItemGroupInput);
	auto typeUpdateUserFilter = schema::InputObjectType::Make(R"gql(UpdateUserFilter)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(UpdateUserFilter)gql"sv, typeUpdateUserFilter);
	auto typeUpdateUserDataInput = schema::InputObjectType::Make(R"gql(UpdateUserDataInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(UpdateUserDataInput)gql"sv, typeUpdateUserDataInput);
	auto typeUpdateItemInput = schema::InputObjectType::Make(R"gql(UpdateItemInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(UpdateItemInput)gql"sv, typeUpdateItemInput);
	auto typeUpdateItemBrandInput = schema::InputObjectType::Make(R"gql(UpdateItemBrandInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(UpdateItemBrandInput)gql"sv, typeUpdateItemBrandInput);
	auto typeGetUserInput = schema::InputObjectType::Make(R"gql(GetUserInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(GetUserInput)gql"sv, typeGetUserInput);
	auto typeGetItemInput = schema::InputObjectType::Make(R"gql(GetItemInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(GetItemInput)gql"sv, typeGetItemInput);
	auto typeGetItemGroupInput = schema::InputObjectType::Make(R"gql(GetItemGroupInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(GetItemGroupInput)gql"sv, typeGetItemGroupInput);
	auto typeGetItemBrandInput = schema::InputObjectType::Make(R"gql(GetItemBrandInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(GetItemBrandInput)gql"sv, typeGetItemBrandInput);
	auto typeSearchUsersInput = schema::InputObjectType::Make(R"gql(SearchUsersInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(SearchUsersInput)gql"sv, typeSearchUsersInput);
	auto typeSearchItemsInput = schema::InputObjectType::Make(R"gql(SearchItemsInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(SearchItemsInput)gql"sv, typeSearchItemsInput);
	auto typeSearchItemGroupsInput = schema::InputObjectType::Make(R"gql(SearchItemGroupsInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(SearchItemGroupsInput)gql"sv, typeSearchItemGroupsInput);
	auto typeSearchItemBrandsInput = schema::InputObjectType::Make(R"gql(SearchItemBrandsInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(SearchItemBrandsInput)gql"sv, typeSearchItemBrandsInput);
	auto typeChangePasswordInput = schema::InputObjectType::Make(R"gql(ChangePasswordInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(ChangePasswordInput)gql"sv, typeChangePasswordInput);
	auto typeUpdateUserPoliciesInput = schema::InputObjectType::Make(R"gql(UpdateUserPoliciesInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(UpdateUserPoliciesInput)gql"sv, typeUpdateUserPoliciesInput);
	auto typeUpdateItemGroupInput = schema::InputObjectType::Make(R"gql(UpdateItemGroupInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(UpdateItemGroupInput)gql"sv, typeUpdateItemGroupInput);
	auto typeSessionParams = schema::InputObjectType::Make(R"gql(SessionParams)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(SessionParams)gql"sv, typeSessionParams);
	auto typeLogoutParams = schema::InputObjectType::Make(R"gql(LogoutParams)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(LogoutParams)gql"sv, typeLogoutParams);
	auto typeUpdateUserInput = schema::InputObjectType::Make(R"gql(UpdateUserInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(UpdateUserInput)gql"sv, typeUpdateUserInput);
	auto typeUser = schema::ObjectType::Make(R"gql(User)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(User)gql"sv, typeUser);
	auto typeAuthPayLoad = schema::ObjectType::Make(R"gql(AuthPayLoad)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(AuthPayLoad)gql"sv, typeAuthPayLoad);
	auto typeLogoutPayload = schema::ObjectType::Make(R"gql(LogoutPayload)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(LogoutPayload)gql"sv, typeLogoutPayload);
	auto typeItem = schema::ObjectType::Make(R"gql(Item)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(Item)gql"sv, typeItem);
	auto typeItemGroup = schema::ObjectType::Make(R"gql(ItemGroup)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(ItemGroup)gql"sv, typeItemGroup);
	auto typeItemBrand = schema::ObjectType::Make(R"gql(ItemBrand)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(ItemBrand)gql"sv, typeItemBrand);
	auto typeUserQuery = schema::ObjectType::Make(R"gql(UserQuery)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(UserQuery)gql"sv, typeUserQuery);
	auto typeItemQuery = schema::ObjectType::Make(R"gql(ItemQuery)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(ItemQuery)gql"sv, typeItemQuery);
	auto typeItemGroupQuery = schema::ObjectType::Make(R"gql(ItemGroupQuery)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(ItemGroupQuery)gql"sv, typeItemGroupQuery);
	auto typeItemBrandQuery = schema::ObjectType::Make(R"gql(ItemBrandQuery)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(ItemBrandQuery)gql"sv, typeItemBrandQuery);
	auto typeUserMutation = schema::ObjectType::Make(R"gql(UserMutation)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(UserMutation)gql"sv, typeUserMutation);
	auto typeSessionMutation = schema::ObjectType::Make(R"gql(SessionMutation)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(SessionMutation)gql"sv, typeSessionMutation);
	auto typeItemMutation = schema::ObjectType::Make(R"gql(ItemMutation)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(ItemMutation)gql"sv, typeItemMutation);
	auto typeItemGroupMutation = schema::ObjectType::Make(R"gql(ItemGroupMutation)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(ItemGroupMutation)gql"sv, typeItemGroupMutation);
	auto typeItemBrandMutation = schema::ObjectType::Make(R"gql(ItemBrandMutation)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(ItemBrandMutation)gql"sv, typeItemBrandMutation);
	auto typeQuery = schema::ObjectType::Make(R"gql(Query)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(Query)gql"sv, typeQuery);
	auto typeMutation = schema::ObjectType::Make(R"gql(Mutation)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(Mutation)gql"sv, typeMutation);

	typeLogoutReason->AddEnumValues({
		{ service::s_namesLogoutReason[static_cast<size_t>(omnisphere::LogoutReason::UNDEFINED)], R"md()md"sv, std::nullopt },
		{ service::s_namesLogoutReason[static_cast<size_t>(omnisphere::LogoutReason::USER_LOGOUT)], R"md()md"sv, std::nullopt },
		{ service::s_namesLogoutReason[static_cast<size_t>(omnisphere::LogoutReason::SESSION_TIMEOUT)], R"md()md"sv, std::nullopt },
		{ service::s_namesLogoutReason[static_cast<size_t>(omnisphere::LogoutReason::TOKEN_EXPIRED)], R"md()md"sv, std::nullopt },
		{ service::s_namesLogoutReason[static_cast<size_t>(omnisphere::LogoutReason::FORCE_LOGOUT)], R"md()md"sv, std::nullopt },
		{ service::s_namesLogoutReason[static_cast<size_t>(omnisphere::LogoutReason::DEVICE_DISCONNECTED)], R"md()md"sv, std::nullopt },
		{ service::s_namesLogoutReason[static_cast<size_t>(omnisphere::LogoutReason::SECURITY_EVENT)], R"md()md"sv, std::nullopt }
	});

	typeCreateUserInput->AddInputValues({
		schema::InputValue::Make(R"gql(Code)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Name)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Email)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Phone)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Employee)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Int)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Password)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(SuperUser)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Boolean)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(ChangePasswordNextLogin)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Boolean)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(PasswordNeverExpires)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Boolean)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(CreatedBy)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Int)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(CreateDate)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv)
	});
	typeCreateItemInput->AddInputValues({
		schema::InputValue::Make(R"gql(Code)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Name)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Description)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Image)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(IsActive)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Boolean)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(PurchaseItem)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Boolean)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(SellItem)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Boolean)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(InventoryItem)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Boolean)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Price)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Float)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Brand)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Int)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Group)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Int)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MinStock)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MaxStock)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MinOrder)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MaxOrder)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MinRequest)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MaxRequest)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(CreatedBy)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Int)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(CreateDate)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv)
	});
	typeCreateItemBrandInput->AddInputValues({
		schema::InputValue::Make(R"gql(Code)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Name)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(CreatedBy)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Int)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(CreateDate)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv)
	});
	typeCreateItemGroupInput->AddInputValues({
		schema::InputValue::Make(R"gql(Code)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Name)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(CreatedBy)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Int)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(CreateDate)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv)
	});
	typeUpdateUserFilter->AddInputValues({
		schema::InputValue::Make(R"gql(Entry)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Int)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Code)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv)
	});
	typeUpdateUserDataInput->AddInputValues({
		schema::InputValue::Make(R"gql(Name)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Email)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Phone)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Employee)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Int)gql"sv)), R"gql()gql"sv)
	});
	typeUpdateItemInput->AddInputValues({
		schema::InputValue::Make(R"gql(Code)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Name)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Description)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Image)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(IsActive)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Boolean)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(PurchaseItem)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Boolean)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(SellItem)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Boolean)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(InventoryItem)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Boolean)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Price)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Brand)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Int)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Group)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Int)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MinStock)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MaxStock)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MinOrder)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MaxOrder)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MinRequest)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MaxRequest)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(LastUpdatedBy)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Int)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(UpdateDate)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv)
	});
	typeUpdateItemBrandInput->AddInputValues({
		schema::InputValue::Make(R"gql(Code)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Name)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(LastUpdatedBy)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Int)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(UpdateDate)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv)
	});
	typeGetUserInput->AddInputValues({
		schema::InputValue::Make(R"gql(Entry)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Int)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Code)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Name)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Email)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Phone)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Employee)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Int)gql"sv), R"gql()gql"sv)
	});
	typeGetItemInput->AddInputValues({
		schema::InputValue::Make(R"gql(Entry)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Int)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Code)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Name)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv)
	});
	typeGetItemGroupInput->AddInputValues({
		schema::InputValue::Make(R"gql(Code)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Name)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv)
	});
	typeGetItemBrandInput->AddInputValues({
		schema::InputValue::Make(R"gql(Code)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Name)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv)
	});
	typeSearchUsersInput->AddInputValues({
		schema::InputValue::Make(R"gql(AllOff)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Boolean)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(AnyOff)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Boolean)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(CodeEqualsTo)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(CodeContains)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(NameEqualsTo)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(NameConatins)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(EmailEqualsTo)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(EmailContains)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(PhoneEqualsTo)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(PhoneContains)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(InactiveUsers)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Boolean)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(LockedUsers)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Boolean)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(HasEmployee)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Boolean)gql"sv), R"gql()gql"sv)
	});
	typeSearchItemsInput->AddInputValues({
		schema::InputValue::Make(R"gql(CodeEqualsTo)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(CodeContains)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(NameEqualsTo)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(NameContains)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(DescriptionEqualsTo)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(DescriptionContains)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(IsActive)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Boolean)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(PurchaseItem)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Boolean)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(SellItem)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Boolean)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(InventoryItem)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Boolean)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Price)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(OnHandEqualsTo)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(OnHandGreaterThan)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(OnHandLessThan)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(OnRequestEqualsTo)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(OnRequestGreaterThan)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(OnRequestLessThan)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(OnOrderEqualsTo)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(OnOrderGreaterThan)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(OnOrderLessThan)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MinStockEqualsTo)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MinStockGreaterThan)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MinStockLessThan)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MaxStockEqualsTo)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MaxStockGreaterThan)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MaxStockLessThan)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MinOrderEqualsTo)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MinOrderGreaterThan)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MinOrderLessThan)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MaxOrderEqualsTo)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MaxOrderGreaterThan)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MaxOrderLessThan)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MinRequestEqualsTo)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MinRequestGreaterThan)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MinRequestLessThan)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MaxReqeuestEqualsTo)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MaxRequestGreaterThan)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(MaxRequestLessThan)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Float)gql"sv), R"gql()gql"sv)
	});
	typeSearchItemGroupsInput->AddInputValues({
		schema::InputValue::Make(R"gql(NameEqualsTo)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(NameContains)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv)
	});
	typeSearchItemBrandsInput->AddInputValues({
		schema::InputValue::Make(R"gql(NameEqualsTo)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(NameContains)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv)
	});
	typeChangePasswordInput->AddInputValues({
		schema::InputValue::Make(R"gql(Entry)gql"sv, R"md()md"sv, schema->LookupType(R"gql(Int)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Code)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(OldPassword)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(NewPassword)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(UpdateDate)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(UpdatedBy)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Int)gql"sv)), R"gql()gql"sv)
	});
	typeUpdateUserPoliciesInput->AddInputValues({
		schema::InputValue::Make(R"gql(Entry)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Int)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Code)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(IsActive)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Boolean)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(IsLocked)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Boolean)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(SuperUser)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Boolean)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(ChangePasswordNextLogin)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Boolean)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(PasswordNeverExpires)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Boolean)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(UpdateDate)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(UpdatedBy)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Int)gql"sv)), R"gql()gql"sv)
	});
	typeUpdateItemGroupInput->AddInputValues({
		schema::InputValue::Make(R"gql(Code)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Name)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(LastUpdatedBy)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Int)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(UpdateDate)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv)
	});
	typeSessionParams->AddInputValues({
		schema::InputValue::Make(R"gql(Code)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Email)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Phone)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(StartDate)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(DeviceIP)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(HostName)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Password)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv)
	});
	typeLogoutParams->AddInputValues({
		schema::InputValue::Make(R"gql(SessionUUID)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(EndDate)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Reason)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(LogoutReason)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Message)gql"sv, R"md()md"sv, schema->LookupType(R"gql(String)gql"sv), R"gql()gql"sv)
	});
	typeUpdateUserInput->AddInputValues({
		schema::InputValue::Make(R"gql(Where)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(UpdateUserFilter)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(Data)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(UpdateUserDataInput)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(UpdateDate)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(String)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(UpdatedBy)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Int)gql"sv)), R"gql()gql"sv)
	});

	AddUserDetails(typeUser, schema);
	AddAuthPayLoadDetails(typeAuthPayLoad, schema);
	AddLogoutPayloadDetails(typeLogoutPayload, schema);
	AddItemDetails(typeItem, schema);
	AddItemGroupDetails(typeItemGroup, schema);
	AddItemBrandDetails(typeItemBrand, schema);
	AddUserQueryDetails(typeUserQuery, schema);
	AddItemQueryDetails(typeItemQuery, schema);
	AddItemGroupQueryDetails(typeItemGroupQuery, schema);
	AddItemBrandQueryDetails(typeItemBrandQuery, schema);
	AddUserMutationDetails(typeUserMutation, schema);
	AddSessionMutationDetails(typeSessionMutation, schema);
	AddItemMutationDetails(typeItemMutation, schema);
	AddItemGroupMutationDetails(typeItemGroupMutation, schema);
	AddItemBrandMutationDetails(typeItemBrandMutation, schema);
	AddQueryDetails(typeQuery, schema);
	AddMutationDetails(typeMutation, schema);

	schema->AddQueryType(typeQuery);
	schema->AddMutationType(typeMutation);
}

std::shared_ptr<schema::Schema> GetSchema()
{
	static std::weak_ptr<schema::Schema> s_wpSchema;
	auto schema = s_wpSchema.lock();

	if (!schema)
	{
		schema = std::make_shared<schema::Schema>(false, R"md()md"sv);
		introspection::AddTypesToSchema(schema);
		AddTypesToSchema(schema);
		s_wpSchema = schema;
	}

	return schema;
}

} // namespace omnisphere
} // namespace graphql
